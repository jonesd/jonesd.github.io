<html>
<html>
<head>
<title>Class ScruSet</title>
</head><body>
<a href="index.html">Index</a> - <a href="AllPackages.html">All Packages</a> - <a href="AllCategories.html">All Categories</a> - <a href="AllClasses.html">All Classes</a><br><h1>Class ScruSet</h1>
<font color="green">X++ has three basic kinds of collection classes.  Tables, <a href="Set.html">Sets</a> and XuRegions.  XuRegions are not-necessarily-discrete collections of positions, and are documented in the space module.  <a href="Set.html">Sets</a> and Tables are both discrete and finite, and similar in many ways.  Both originate in a three-way type distinction between:<br>	<br>	ScruX  --  The protocol for examining one.  Ie., it is *Scru*table<br>	ImmuX  --  The contract guarantees that the set or table you're looking at won't change (though the things it contains may change)<br>	MuX  --  Additional protocol for changing it.<br><br>		<br>	Concrete classes may be a subclass of any of the above.  It makes sense to have a concrete subclass of ScruX which isn't a subclass of either MuX or ImmuX when, for example, it represents a tracking, filtered view of some other set which is itself changing.  All kinds of collection can be iterated over when appropriate using <a href="Stepper.html">Steppers</a>--our basic iteration abstraction (see <a href="Stepper.html">Stepper</a>).<br><br>	Immu's are sort of like Stamps -- they represent a particular state a colection can have.  Mu's are sort of like Berts -- they represent a continuing collection identity which can change its current state.<br>	<br>	<a href="Set.html">Sets</a> are pure collections--their contents are just a set of <a href="Heaper.html">Heapers</a>.  <a href="Set.html">Sets</a> (as opposed to tables) do not provide any organization of these contents.<br></font></p>Package: <a href="Package_Udanax-Gold.html">Udanax-Gold</a><br>All Superclasses: <a href="Object.html">Object</a> <a href="Heaper.html">Heaper</a> <br>Immediate Subclasses: <a href="ImmuSet.html">ImmuSet</a> <a href="MuSet.html">MuSet</a> <br>Protocols: <a href="Protocol_Object.html">Object</a><br>Categories: <a href="Category_Xanadu-Collection-Sets.html">Xanadu-Collection-Sets</a><br><hr><h2>Class Methods</h3><a name="#problemsNotInSet"><h4><font color="blue">problemsNotInSet</font> </h4></a><blockquote><font color="green"><br></font></blockquote><hr><h2>Instance Methods</h3><a name="#actualHashForEqual"><h4><font color="blue">actualHashForEqual</font> </h4></a><blockquote><font color="green"><br></font><br>Overridden by: <a href="ImmuSet.html#actualHashForEqual">ImmuSet</a> <a href="MuSet.html#actualHashForEqual">MuSet</a> </blockquote><a name="#asArray"><h4><font color="blue">asArray</font> </h4></a><blockquote><font color="green">The elements in the set in an array, in some random order<br></font></blockquote><a name="#asImmuSet"><h4><font color="blue">asImmuSet</font> </h4></a><blockquote><font color="green">Return an immu snapshot of my current state. Should probably be done with a <br>	Converter rather than with a message (for the reasons listed in the Converter <br>	class comment). In terms of the Stamp/Bert analogy mentioned in the class <br>	comment, asImmuSet is like asking for the current Stamp.<br></font><br>Overridden by: <a href="ImmuSet.html#asImmuSet">ImmuSet</a> <a href="MuSet.html#asImmuSet">MuSet</a> <a href="GrandHashSet.html#asImmuSet">GrandHashSet</a> <a href="HashSet.html#asImmuSet">HashSet</a> </blockquote><a name="#asMuSet"><h4><font color="blue">asMuSet</font> </h4></a><blockquote><font color="green">Return a Mu whose initial state is the same as my current state, but which <br>	will now deviate independently of me. In terms of the Stamp/Bert analogy <br>	mentioned in the class comment, asMuSet is like asking for a new Bert starting <br>	on the current Stamp.<br></font><br>Overridden by: <a href="ImmuSet.html#asMuSet">ImmuSet</a> <a href="EmptyImmuSet.html#asMuSet">EmptyImmuSet</a> <a href="ImmuSetOnMu.html#asMuSet">ImmuSetOnMu</a> <a href="TinyImmuSet.html#asMuSet">TinyImmuSet</a> <a href="MuSet.html#asMuSet">MuSet</a> <a href="GrandHashSet.html#asMuSet">GrandHashSet</a> <a href="HashSet.html#asMuSet">HashSet</a> </blockquote><a name="#asOrderedCollection"><h4><font color="blue">asOrderedCollection</font> </h4></a><blockquote><font color="green">return all of my elements in an ordered collection for smalltalk MVC hacking<br></font></blockquote><a name="#contentsEqual:"><h4><font color="blue">contentsEqual:</font> other </h4></a><blockquote><font color="green">Returns whether the two <a href="ScruSet.html">ScruSets</a> have exactly the same set of elements at the moment.<br>	'a->contentsEqual(b)' is equivalent to <br>	'a->asImmuSet()->isEqual(b->asImmuSet())'.<br></font></blockquote><a name="#contentsHash"><h4><font color="blue">contentsHash</font> </h4></a><blockquote><font color="green">Has the same relationship to contentsEqual that hashForEqual has to isEqual. <br>	Ie., if 'a->contentsEqual (b)', then 'a->contentsHash() == b->contentsHash()'. <br>	The same complex caveats apply as to the stability and portability of the <br>	hash values as apply for hashForEqual.<br></font><br>Overridden by: <a href="ActualHashSet.html#contentsHash">ActualHashSet</a> </blockquote><a name="#copy"><h4><font color="blue">copy</font> </h4></a><blockquote><font color="green">A new one whose initial state is my current state, but that doesn't track <br>	changes. Note that there is no implication that these can be 'destroy'ed <br>	separately, because (for example) an <a href="ImmuSet.html">ImmuSet</a> just returns itself<br></font><br>Overrides: <a href="Object.html#copy">Object</a><br>Overridden by: <a href="ImmuSet.html#copy">ImmuSet</a> <a href="MuSet.html#copy">MuSet</a> <a href="GrandHashSet.html#copy">GrandHashSet</a> <a href="HashSet.html#copy">HashSet</a> <a href="ActualHashSet.html#copy">ActualHashSet</a> </blockquote><a name="#count"><h4><font color="blue">count</font> </h4></a><blockquote><font color="green">How many elements are currently in the set.  Being a set, if the same element is put into the set twice,<br>	it is only in the set once.  'Same' above is according to 'isEqual'.<br></font><br>Overridden by: <a href="ImmuSet.html#count">ImmuSet</a> <a href="EmptyImmuSet.html#count">EmptyImmuSet</a> <a href="ImmuSetOnMu.html#count">ImmuSetOnMu</a> <a href="TinyImmuSet.html#count">TinyImmuSet</a> <a href="MuSet.html#count">MuSet</a> <a href="GrandHashSet.html#count">GrandHashSet</a> <a href="HashSet.html#count">HashSet</a> <a href="ActualHashSet.html#count">ActualHashSet</a> </blockquote><a name="#do:"><h4><font color="blue">do:</font> aBlock </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#hasMember:"><h4><font color="blue">hasMember:</font> someone </h4></a><blockquote><font color="green">Is someone a member of the set now?<br></font><br>Overridden by: <a href="ImmuSet.html#hasMember:">ImmuSet</a> <a href="EmptyImmuSet.html#hasMember:">EmptyImmuSet</a> <a href="ImmuSetOnMu.html#hasMember:">ImmuSetOnMu</a> <a href="TinyImmuSet.html#hasMember:">TinyImmuSet</a> <a href="MuSet.html#hasMember:">MuSet</a> <a href="GrandHashSet.html#hasMember:">GrandHashSet</a> <a href="HashSet.html#hasMember:">HashSet</a> <a href="ActualHashSet.html#hasMember:">ActualHashSet</a> </blockquote><a name="#inspect"><h4><font color="blue">inspect</font> </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="Object.html#inspect">Object</a></blockquote><a name="#intersects:"><h4><font color="blue">intersects:</font> other </h4></a><blockquote><font color="green">tell whether they have any points in common<br></font></blockquote><a name="#isEmpty"><h4><font color="blue">isEmpty</font> </h4></a><blockquote><font color="green">Whether it currently has any elements<br></font><br>Overridden by: <a href="ImmuSet.html#isEmpty">ImmuSet</a> <a href="EmptyImmuSet.html#isEmpty">EmptyImmuSet</a> <a href="ImmuSetOnMu.html#isEmpty">ImmuSetOnMu</a> <a href="TinyImmuSet.html#isEmpty">TinyImmuSet</a> <a href="MuSet.html#isEmpty">MuSet</a> <a href="GrandHashSet.html#isEmpty">GrandHashSet</a> <a href="HashSet.html#isEmpty">HashSet</a> <a href="ActualHashSet.html#isEmpty">ActualHashSet</a> </blockquote><a name="#isEqual:"><h4><font color="blue">isEqual:</font> other </h4></a><blockquote><font color="green"><br></font><br>Overridden by: <a href="ImmuSet.html#isEqual:">ImmuSet</a> <a href="MuSet.html#isEqual:">MuSet</a> </blockquote><a name="#isSubsetOf:"><h4><font color="blue">isSubsetOf:</font> another </h4></a><blockquote><font color="green">Whether another currently has all my elements<br></font><br>Overridden by: <a href="EmptyImmuSet.html#isSubsetOf:">EmptyImmuSet</a> <a href="ImmuSetOnMu.html#isSubsetOf:">ImmuSetOnMu</a> <a href="TinyImmuSet.html#isSubsetOf:">TinyImmuSet</a> </blockquote><a name="#printOn:"><h4><font color="blue">printOn:</font> oo </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="Object.html#printOn:">Object</a><br>Overridden by: <a href="GrandHashSet.html#printOn:">GrandHashSet</a> </blockquote><a name="#printOnWithSimpleSyntax:with:with:with:"><h4><font color="blue">printOnWithSimpleSyntax:</font> oo <font color="blue">with:</font> open <font color="blue">with:</font> sep <font color="blue">with:</font> close </h4></a><blockquote><font color="green"><br></font><br>Overridden by: <a href="GrandHashSet.html#printOnWithSimpleSyntax:with:with:with:">GrandHashSet</a> </blockquote><a name="#printOnWithSyntax:with:with:with:with:"><h4><font color="blue">printOnWithSyntax:</font> oo <font color="blue">with:</font> open <font color="blue">with:</font> sep <font color="blue">with:</font> close <font color="blue">with:</font> fullPrint </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#stepper"><h4><font color="blue">stepper</font> </h4></a><blockquote><font color="green">Returns a stepper which will enumerate all the elements of the set in some unspecified order<br></font><br>Overridden by: <a href="ImmuSet.html#stepper">ImmuSet</a> <a href="EmptyImmuSet.html#stepper">EmptyImmuSet</a> <a href="ImmuSetOnMu.html#stepper">ImmuSetOnMu</a> <a href="TinyImmuSet.html#stepper">TinyImmuSet</a> <a href="MuSet.html#stepper">MuSet</a> <a href="GrandHashSet.html#stepper">GrandHashSet</a> <a href="HashSet.html#stepper">HashSet</a> <a href="ActualHashSet.html#stepper">ActualHashSet</a> </blockquote><a name="#theOne"><h4><font color="blue">theOne</font> </h4></a><blockquote><font color="green">Iff I contain exactly one member, return it.  Otherwise BLAST.<br>	The idea for this message is taken from the THE function of ONTIC<br>	(reference McAllester)<br></font><br>Overridden by: <a href="EmptyImmuSet.html#theOne">EmptyImmuSet</a> <a href="ImmuSetOnMu.html#theOne">ImmuSetOnMu</a> <a href="TinyImmuSet.html#theOne">TinyImmuSet</a> <a href="HashSet.html#theOne">HashSet</a> <a href="ActualHashSet.html#theOne">ActualHashSet</a> </blockquote><br><br><a href="index.html">Index</a> - <a href="AllPackages.html">All Packages</a> - <a href="AllCategories.html">All Categories</a> - <a href="AllClasses.html">All Classes</a><br></body>
</html>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5004449-1");
pageTracker._initData();
pageTracker._trackPageview();
</script>
</body>
</html>
