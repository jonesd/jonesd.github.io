<html>
<html>
<head>
<title>Class XnRegion</title>
</head><body>
<a href="index.html">Index</a> - <a href="AllPackages.html">All Packages</a> - <a href="AllCategories.html">All Categories</a> - <a href="AllClasses.html">All Classes</a><br><h1>Class XnRegion</h1>
<font color="green">The design of a new coordinate space consists mostly in the design of the XuRegions which can be used to describe (possibly infinite) sets of positions in that coordinate space.  It will generally not be the case (for a given coordinate space) that all mathematically describable sets of positions will be representable by an XuRegion in that space.  This should not be seen as a temporary deficiency of the current implementation of a space, but rather part of the design of what a given space *means*.  <br>	<br>	For example, in <a href="IntegerSpace.html">IntegerSpace</a>, one cannot form the XuRegion whose members are exactly the even numbers.  If this were possible, other desirable properties which are part of the intent of <a href="IntegerSpace.html">IntegerSpaces</a> would no longer be possible.  For example, any XuRegion should be able to break itself up into a finite number of simple XuRegions ("simple" is described below).  Were an even number region possible, this would have undesirable consequences for the definition of "simple" in this space.  If you want (for example) to be able to have a XuRegion which can represent all the even numbers, it probably makes more sense to define a whole new space in which these new XuRegions apply.<br>	<br>	XuRegions should be closed under a large set of operations, such as intersection, unionWith, complement and minus.  ("closed" means that the result of performing this operation on XuRegions of a given space is another valid XuRegion in the same space.)  Additional guarantees are documented with each operation.<br>	<br>	A XuRegion may be classified at one of three levels of "simplicity":<br>	<br>	1) The simplest are the *distinctions*.  Distinctions are those that answer with (at most) a single set containing themselves in response to the message "distinctions".  (The reason I say "at most" is that a full region (one that covers the entire coordinate space) may answer with the empty set.)  Distinctions are the simplest XuRegions of a given space out of which all other XuRegions of that space can be finitely composed.  There should probably be a message "isDistinction" for which exactly the distinctions answer "true".  The complement of a distinction is a distinction.  Three examples of distinctions in spaces are:<br>	<br>		a) in <a href="IntegerSpace.html">IntegerSpace</a>, any simple inequality.  For example, all integers < 37.<br>		b) in one kind of 3-space, any half space (all the space on one side of some plane)<br>		c) in another kind of 3-space, any sphere or spherical hole.<br>		<br>	Note that "c" could not just have spheres as the distinction because distinctions must be closed under complement.  (We are here ignoring the quite substantial problems that arise in dealing with approximate (eg., floating point) which would almost necessarily have to arise in doing any decent 3-space.  3-space is nevertheless a good intuition pump.)<br>	<br>	2) Next are the *simple regions*.  Simple regions are exactly those that say "true" to "isSimple".  All distinctions are also simple regions.  In response to the message "distinctions", and simple region must return a finite set of distinctions which, when intersected together, yield the original simple region.  Generally, one tries to define the simple regions for a space to correspond to some notion of locality in the space.  For example, it may be good for a simple region not to be able to have a hole in it.  Or perhaps a simple region is which must be connected (whatever that means in a given space).  Example non-distinction simple regions for the above example spaces would be:<br>	<br>		a) The interval from 3 inclusive to 17 exclusive (intersection of all integers >= 3 and all < 17)<br>		b) A convex hull (intersection of half spaces)<br>		c) Whatever you get by intersecting a bunch of spheres and sherical holes.<br>		<br>	The simple regions for both "a" and "b" would be connected, without holes, and even convex.  This follows directly from the definition of our distinctions.  None of these nice properties holds for "c", and this also follows directly from our decision to start with spheres.  "c" is still perfectly valid, just less preferable by some criteria.<br>	<br>	3) Finally, there are the regions of a space in general.  Any region must respond to the message "simpleRegions" with a stepper which will produce a finite number of simple regions that, when unioned together, yields the original region.  A simple region will return a stepper that will return at most itself ("at most" because an empty region (which covers no positions) may return an empty stepper).  Example non-simple regions are:<br>	<br>		a) all integers < 3 and all integers >= 17<br>		b) two convex hulls<br>		c) two disjoint spheres<br>		<br>	Note that "a" is the complement of the earlier "a" example, thereby showing why the complement of a simple region isn`t necessarily simple.  Even though the "c" space is so unconstrained in the properties of its simple regions, there is no way to interect a finite number of spheres and spherical holes to produce a pair of disjoint spheres.  Therefore the pair is non-simple.  Not all spaces must have non-simple regions (or even non-distinctions).  It is interesting to observe for "b" and "c" that even though there is a natural conversion between their respective positions, (except for the empty and full regions) there is no conversion at all between their respective regions.  The kinds of sets of positions representable in one space is completely different than those representable in the other space.<br>	<br>	We will use these three example spaces repeatedly in documenting the protocol.<br></font></p>Package: <a href="Package_Udanax-Gold.html">Udanax-Gold</a><br>All Superclasses: <a href="Object.html">Object</a> <a href="Heaper.html">Heaper</a> <br>Immediate Subclasses: <a href="CrossRegion.html">CrossRegion</a> <a href="Filter.html">Filter</a> <a href="IDRegion.html">IDRegion</a> <a href="IntegerRegion.html">IntegerRegion</a> <a href="RealRegion.html">RealRegion</a> <a href="SequenceRegion.html">SequenceRegion</a> <a href="SetRegion.html">SetRegion</a> <br>Protocols: <a href="Protocol_Object.html">Object</a><br>Categories: <a href="Category_Xanadu-Spaces-Basic.html">Xanadu-Spaces-Basic</a><br><hr><h2>Class Methods</h3><a name="#immuSetmake:"><h4><font color="blue">immuSetmake:</font> region </h4></a><blockquote><font color="green">Make a set containing all the positions in the region<br></font></blockquote><a name="#infostProtocol"><h4><font color="blue">infostProtocol</font> </h4></a><blockquote><font color="green"><br></font><br>Overridden by: <a href="CrossRegion.html#infostProtocol">CrossRegion class</a> <a href="Filter.html#infostProtocol">Filter class</a> <a href="IDRegion.html#infostProtocol">IDRegion class</a> <a href="IntegerRegion.html#infostProtocol">IntegerRegion class</a> <a href="RealRegion.html#infostProtocol">RealRegion class</a> <a href="SequenceRegion.html#infostProtocol">SequenceRegion class</a> </blockquote><hr><h2>Instance Methods</h3><a name="#actualHashForEqual"><h4><font color="blue">actualHashForEqual</font> </h4></a><blockquote><font color="green"><br></font><br>Overridden by: <a href="CrossRegion.html#actualHashForEqual">CrossRegion</a> <a href="GenericCrossRegion.html#actualHashForEqual">GenericCrossRegion</a> <a href="Filter.html#actualHashForEqual">Filter</a> <a href="AndFilter.html#actualHashForEqual">AndFilter</a> <a href="ClosedFilter.html#actualHashForEqual">ClosedFilter</a> <a href="NotSubsetFilter.html#actualHashForEqual">NotSubsetFilter</a> <a href="NotSupersetFilter.html#actualHashForEqual">NotSupersetFilter</a> <a href="OpenFilter.html#actualHashForEqual">OpenFilter</a> <a href="OrFilter.html#actualHashForEqual">OrFilter</a> <a href="SubsetFilter.html#actualHashForEqual">SubsetFilter</a> <a href="SupersetFilter.html#actualHashForEqual">SupersetFilter</a> <a href="IDRegion.html#actualHashForEqual">IDRegion</a> <a href="IntegerRegion.html#actualHashForEqual">IntegerRegion</a> <a href="RealRegion.html#actualHashForEqual">RealRegion</a> <a href="SequenceRegion.html#actualHashForEqual">SequenceRegion</a> <a href="SetRegion.html#actualHashForEqual">SetRegion</a> </blockquote><a name="#actualStepper:"><h4><font color="blue">actualStepper:</font> order </h4></a><blockquote><font color="green">Only called if I've already said I'm enumerable in the originally stated order.  Also, if the originally stated order was nil, I get a guaranteed non-nil order.  Subclasses which override 'stepper' to a method which doesn't send 'actualStepper' may override 'actualStepper' to a stub method which always BLASTs.<br></font><br>Overridden by: <a href="CrossRegion.html#actualStepper:">CrossRegion</a> <a href="GenericCrossRegion.html#actualStepper:">GenericCrossRegion</a> <a href="Filter.html#actualStepper:">Filter</a> <a href="ClosedFilter.html#actualStepper:">ClosedFilter</a> <a href="IDRegion.html#actualStepper:">IDRegion</a> <a href="IntegerRegion.html#actualStepper:">IntegerRegion</a> <a href="RealRegion.html#actualStepper:">RealRegion</a> <a href="SequenceRegion.html#actualStepper:">SequenceRegion</a> <a href="SetRegion.html#actualStepper:">SetRegion</a> </blockquote><a name="#asArray:"><h4><font color="blue">asArray:</font> order </h4></a><blockquote><font color="green">Returns all the <a href="Position.html">Positions</a> in the region in order according to 'order'.  If the region isn't finite, then this BLASTs.<br></font></blockquote><a name="#asSimpleRegion"><h4><font color="blue">asSimpleRegion</font> </h4></a><blockquote><font color="green">Return a simple region containing all positions contained by myself. <br>	If I am simple, then the result must be me.  Otherwise,<br>	the resulting region will contain more positions than I do, but it <br>	must contain all those that I do.  It would be good for the resulting <br>	simple region to not contain many more points than it needs in order <br>	to satisfy these constraints; but this is a preference, not a <br>	specification. Particular spaces may specify stronger guarantees, <br>	but as far as class XuRegion is concerned it is correct (though silly) <br>	for this message to always return the full region for the space.<br></font><br>Overridden by: <a href="CrossRegion.html#asSimpleRegion">CrossRegion</a> <a href="GenericCrossRegion.html#asSimpleRegion">GenericCrossRegion</a> <a href="Filter.html#asSimpleRegion">Filter</a> <a href="IDRegion.html#asSimpleRegion">IDRegion</a> <a href="IntegerRegion.html#asSimpleRegion">IntegerRegion</a> <a href="RealRegion.html#asSimpleRegion">RealRegion</a> <a href="SequenceRegion.html#asSimpleRegion">SequenceRegion</a> <a href="SetRegion.html#asSimpleRegion">SetRegion</a> </blockquote><a name="#chooseMany:"><h4><font color="blue">chooseMany:</font> n </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#chooseMany:with:"><h4><font color="blue">chooseMany:</font> n <font color="blue">with:</font> order </h4></a><blockquote><font color="green">If an <a href="OrderSpec.html">OrderSpec</a> is given, return the first n elements according to that <a href="OrderSpec.html">OrderSpec</a>. If no <a href="OrderSpec.html">OrderSpec</a> is given, then iff I contain at least n positions, return n of them; otherwise BLAST. This should be implemented even by regions that aren't enumerable.  Inspired by the axiom of choice.<br></font></blockquote><a name="#chooseOne"><h4><font color="blue">chooseOne</font> </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#chooseOne:"><h4><font color="blue">chooseOne:</font> order </h4></a><blockquote><font color="green">Essential.  If an <a href="OrderSpec.html">OrderSpec</a> is given, return the first element according to that <a href="OrderSpec.html">OrderSpec</a>. If no <a href="OrderSpec.html">OrderSpec</a> is given, then iff I contain at least one position, return one of them; otherwise BLAST. This should be implemented even by regions that aren't enumerable.  Inspired by the axiom of choice.<br></font><br>Overridden by: <a href="IntegerRegion.html#chooseOne:">IntegerRegion</a> </blockquote><a name="#complement"><h4><font color="blue">complement</font> </h4></a><blockquote><font color="green">Essential.  Return a region of containing exactly those positions not in this region. The complement of a distinction must be a distinction.<br></font><br>Overridden by: <a href="CrossRegion.html#complement">CrossRegion</a> <a href="GenericCrossRegion.html#complement">GenericCrossRegion</a> <a href="Filter.html#complement">Filter</a> <a href="AndFilter.html#complement">AndFilter</a> <a href="ClosedFilter.html#complement">ClosedFilter</a> <a href="NotSubsetFilter.html#complement">NotSubsetFilter</a> <a href="NotSupersetFilter.html#complement">NotSupersetFilter</a> <a href="OpenFilter.html#complement">OpenFilter</a> <a href="OrFilter.html#complement">OrFilter</a> <a href="SubsetFilter.html#complement">SubsetFilter</a> <a href="SupersetFilter.html#complement">SupersetFilter</a> <a href="IDRegion.html#complement">IDRegion</a> <a href="IntegerRegion.html#complement">IntegerRegion</a> <a href="RealRegion.html#complement">RealRegion</a> <a href="SequenceRegion.html#complement">SequenceRegion</a> <a href="SetRegion.html#complement">SetRegion</a> </blockquote><a name="#coordinateSpace"><h4><font color="blue">coordinateSpace</font> </h4></a><blockquote><font color="green">Essential.  The coordinate space in which this is a region<br></font><br>Overridden by: <a href="CrossRegion.html#coordinateSpace">CrossRegion</a> <a href="GenericCrossRegion.html#coordinateSpace">GenericCrossRegion</a> <a href="Filter.html#coordinateSpace">Filter</a> <a href="IDRegion.html#coordinateSpace">IDRegion</a> <a href="IntegerRegion.html#coordinateSpace">IntegerRegion</a> <a href="RealRegion.html#coordinateSpace">RealRegion</a> <a href="SequenceRegion.html#coordinateSpace">SequenceRegion</a> <a href="SetRegion.html#coordinateSpace">SetRegion</a> <a href="HeaperRegion.html#coordinateSpace">HeaperRegion</a> </blockquote><a name="#count"><h4><font color="blue">count</font> </h4></a><blockquote><font color="green">How many positions do I contain?  If I am not 'isFinite', then this message will BLAST.<br></font><br>Overridden by: <a href="CrossRegion.html#count">CrossRegion</a> <a href="GenericCrossRegion.html#count">GenericCrossRegion</a> <a href="Filter.html#count">Filter</a> <a href="IDRegion.html#count">IDRegion</a> <a href="IntegerRegion.html#count">IntegerRegion</a> <a href="RealRegion.html#count">RealRegion</a> <a href="SequenceRegion.html#count">SequenceRegion</a> <a href="SetRegion.html#count">SetRegion</a> </blockquote><a name="#delta:"><h4><font color="blue">delta:</font> region </h4></a><blockquote><font color="green">The region where they differ.  <br>	a->delta(b) ->isEqual (a->minus(b)->unionWith(b->minus(a)))<br></font></blockquote><a name="#disjointSimpleRegions"><h4><font color="blue">disjointSimpleRegions</font> </h4></a><blockquote><font color="green">emulate default argument of nil<br></font></blockquote><a name="#disjointSimpleRegions:"><h4><font color="blue">disjointSimpleRegions:</font> order </h4></a><blockquote><font color="green">break it up into a set of non-empty simple regions which don't <br>	overlap. This message satisfies all the specs of 'simpleRegions', and <br>	in addition provides for lack of overlap. It may be significantly more <br>	expensive than 'simpleRegions' which is why they both exist.<br></font></blockquote><a name="#distinctions"><h4><font color="blue">distinctions</font> </h4></a><blockquote><font color="green">Break it up into a set of non-full distinctions. It is an error to send <br>	this to a non-simple region. A full region will respond with the nil <br>	set. Other distinctions will respond with a singleton set containing <br>	themselves, and simple regions will respond with a set of distinctions <br>	which, when intersected together, yield the original region.<br></font><br>Overridden by: <a href="CrossRegion.html#distinctions">CrossRegion</a> <a href="GenericCrossRegion.html#distinctions">GenericCrossRegion</a> <a href="Filter.html#distinctions">Filter</a> <a href="IDRegion.html#distinctions">IDRegion</a> <a href="IntegerRegion.html#distinctions">IntegerRegion</a> <a href="RealRegion.html#distinctions">RealRegion</a> <a href="SequenceRegion.html#distinctions">SequenceRegion</a> <a href="SetRegion.html#distinctions">SetRegion</a> </blockquote><a name="#do:"><h4><font color="blue">do:</font> aBlock </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#hasMember:"><h4><font color="blue">hasMember:</font> atPos </h4></a><blockquote><font color="green">Do I contain this position? More than anything else, the behavior of this message is the defining characteristic of an XuRegion. All other messages (except for the simplicity characterization) should be specifiable in terms of the behavior of this message. What an XuRegion *is* (mostly) is a finite decision procedure for accepting or rejecting any given position.<br></font><br>Overridden by: <a href="CrossRegion.html#hasMember:">CrossRegion</a> <a href="GenericCrossRegion.html#hasMember:">GenericCrossRegion</a> <a href="Filter.html#hasMember:">Filter</a> <a href="IDRegion.html#hasMember:">IDRegion</a> <a href="IntegerRegion.html#hasMember:">IntegerRegion</a> <a href="RealRegion.html#hasMember:">RealRegion</a> <a href="SequenceRegion.html#hasMember:">SequenceRegion</a> <a href="SetRegion.html#hasMember:">SetRegion</a> </blockquote><a name="#intersect:"><h4><font color="blue">intersect:</font> other </h4></a><blockquote><font color="green">Essential.  The intersection of two simple regions must be simple. The intersection of two distinctions must therefore be a simple region. The result has exactly those members which both the original regions have.<br></font><br>Overridden by: <a href="CrossRegion.html#intersect:">CrossRegion</a> <a href="GenericCrossRegion.html#intersect:">GenericCrossRegion</a> <a href="Filter.html#intersect:">Filter</a> <a href="ClosedFilter.html#intersect:">ClosedFilter</a> <a href="OpenFilter.html#intersect:">OpenFilter</a> <a href="IDRegion.html#intersect:">IDRegion</a> <a href="IntegerRegion.html#intersect:">IntegerRegion</a> <a href="RealRegion.html#intersect:">RealRegion</a> <a href="SequenceRegion.html#intersect:">SequenceRegion</a> <a href="SetRegion.html#intersect:">SetRegion</a> </blockquote><a name="#intersects:"><h4><font color="blue">intersects:</font> other </h4></a><blockquote><font color="green">Essential.  tell whether it has any points in common<br></font><br>Overridden by: <a href="GenericCrossRegion.html#intersects:">GenericCrossRegion</a> <a href="IntegerRegion.html#intersects:">IntegerRegion</a> <a href="SetRegion.html#intersects:">SetRegion</a> </blockquote><a name="#isDistinction"><h4><font color="blue">isDistinction</font> </h4></a><blockquote><font color="green">Am I a distinction.  See XuRegion class comment for implications of being a distinction.<br></font><br>Overridden by: <a href="GenericCrossRegion.html#isDistinction">GenericCrossRegion</a> </blockquote><a name="#isEmpty"><h4><font color="blue">isEmpty</font> </h4></a><blockquote><font color="green">Every coordinate space has exactly one empty region. It is the one containing no positions. It and only it responds 'true' to this message.<br></font><br>Overridden by: <a href="CrossRegion.html#isEmpty">CrossRegion</a> <a href="GenericCrossRegion.html#isEmpty">GenericCrossRegion</a> <a href="Filter.html#isEmpty">Filter</a> <a href="AndFilter.html#isEmpty">AndFilter</a> <a href="ClosedFilter.html#isEmpty">ClosedFilter</a> <a href="NotSubsetFilter.html#isEmpty">NotSubsetFilter</a> <a href="NotSupersetFilter.html#isEmpty">NotSupersetFilter</a> <a href="OpenFilter.html#isEmpty">OpenFilter</a> <a href="OrFilter.html#isEmpty">OrFilter</a> <a href="SubsetFilter.html#isEmpty">SubsetFilter</a> <a href="SupersetFilter.html#isEmpty">SupersetFilter</a> <a href="IDRegion.html#isEmpty">IDRegion</a> <a href="IntegerRegion.html#isEmpty">IntegerRegion</a> <a href="RealRegion.html#isEmpty">RealRegion</a> <a href="SequenceRegion.html#isEmpty">SequenceRegion</a> <a href="SetRegion.html#isEmpty">SetRegion</a> </blockquote><a name="#isEnumerable"><h4><font color="blue">isEnumerable</font> </h4></a><blockquote><font color="green">emulate default argument of nil<br></font></blockquote><a name="#isEnumerable:"><h4><font color="blue">isEnumerable:</font> order </h4></a><blockquote><font color="green">See comment in XuRegion::stepper.  <br>	a->stepper(os) won't BLAST iff a->isEnumerable(os)<br></font><br>Overridden by: <a href="CrossRegion.html#isEnumerable:">CrossRegion</a> <a href="GenericCrossRegion.html#isEnumerable:">GenericCrossRegion</a> <a href="Filter.html#isEnumerable:">Filter</a> <a href="ClosedFilter.html#isEnumerable:">ClosedFilter</a> <a href="IntegerRegion.html#isEnumerable:">IntegerRegion</a> <a href="RealRegion.html#isEnumerable:">RealRegion</a> <a href="SequenceRegion.html#isEnumerable:">SequenceRegion</a> <a href="SetRegion.html#isEnumerable:">SetRegion</a> <a href="HeaperRegion.html#isEnumerable:">HeaperRegion</a> </blockquote><a name="#isEqual:"><h4><font color="blue">isEqual:</font> other </h4></a><blockquote><font color="green">Two regions are equal iff they contain exactly the same set of positions<br></font><br>Overridden by: <a href="CrossRegion.html#isEqual:">CrossRegion</a> <a href="GenericCrossRegion.html#isEqual:">GenericCrossRegion</a> <a href="Filter.html#isEqual:">Filter</a> <a href="AndFilter.html#isEqual:">AndFilter</a> <a href="ClosedFilter.html#isEqual:">ClosedFilter</a> <a href="NotSubsetFilter.html#isEqual:">NotSubsetFilter</a> <a href="NotSupersetFilter.html#isEqual:">NotSupersetFilter</a> <a href="OpenFilter.html#isEqual:">OpenFilter</a> <a href="OrFilter.html#isEqual:">OrFilter</a> <a href="SubsetFilter.html#isEqual:">SubsetFilter</a> <a href="SupersetFilter.html#isEqual:">SupersetFilter</a> <a href="IDRegion.html#isEqual:">IDRegion</a> <a href="IntegerRegion.html#isEqual:">IntegerRegion</a> <a href="RealRegion.html#isEqual:">RealRegion</a> <a href="SequenceRegion.html#isEqual:">SequenceRegion</a> <a href="SetRegion.html#isEqual:">SetRegion</a> </blockquote><a name="#isFinite"><h4><font color="blue">isFinite</font> </h4></a><blockquote><font color="green">Essential.  Do I contain a finite number of positions? If I do, then the 'count' message will say how many, and I will gladly provide a stepper which will step over all of them. Ie., isFinite implies isEnumerable.<br></font><br>Overridden by: <a href="CrossRegion.html#isFinite">CrossRegion</a> <a href="GenericCrossRegion.html#isFinite">GenericCrossRegion</a> <a href="Filter.html#isFinite">Filter</a> <a href="IDRegion.html#isFinite">IDRegion</a> <a href="IntegerRegion.html#isFinite">IntegerRegion</a> <a href="RealRegion.html#isFinite">RealRegion</a> <a href="SequenceRegion.html#isFinite">SequenceRegion</a> <a href="SetRegion.html#isFinite">SetRegion</a> </blockquote><a name="#isFull"><h4><font color="blue">isFull</font> </h4></a><blockquote><font color="green">true if this is the largest possible region in this space -- the region that contains all positions in the space. Note that in a space which has no positions (which is perfectly valid), the one XuRegion would be both empty (since it has no positions) and full (since it has all the positions in the space).<br></font><br>Overridden by: <a href="GenericCrossRegion.html#isFull">GenericCrossRegion</a> <a href="Filter.html#isFull">Filter</a> <a href="AndFilter.html#isFull">AndFilter</a> <a href="ClosedFilter.html#isFull">ClosedFilter</a> <a href="NotSubsetFilter.html#isFull">NotSubsetFilter</a> <a href="NotSupersetFilter.html#isFull">NotSupersetFilter</a> <a href="OpenFilter.html#isFull">OpenFilter</a> <a href="OrFilter.html#isFull">OrFilter</a> <a href="SubsetFilter.html#isFull">SubsetFilter</a> <a href="SupersetFilter.html#isFull">SupersetFilter</a> <a href="IDRegion.html#isFull">IDRegion</a> <a href="IntegerRegion.html#isFull">IntegerRegion</a> <a href="RealRegion.html#isFull">RealRegion</a> <a href="SequenceRegion.html#isFull">SequenceRegion</a> <a href="SetRegion.html#isFull">SetRegion</a> </blockquote><a name="#isSimple"><h4><font color="blue">isSimple</font> </h4></a><blockquote><font color="green">Am I a simple region.  See XuRegion class comment for implications of being simple.<br></font><br>Overridden by: <a href="CrossRegion.html#isSimple">CrossRegion</a> <a href="GenericCrossRegion.html#isSimple">GenericCrossRegion</a> <a href="Filter.html#isSimple">Filter</a> <a href="IDRegion.html#isSimple">IDRegion</a> <a href="IntegerRegion.html#isSimple">IntegerRegion</a> <a href="RealRegion.html#isSimple">RealRegion</a> <a href="SequenceRegion.html#isSimple">SequenceRegion</a> <a href="SetRegion.html#isSimple">SetRegion</a> </blockquote><a name="#isSubsetOf:"><h4><font color="blue">isSubsetOf:</font> other </h4></a><blockquote><font color="green">I'm a subset of other if I don't have any positions that he doesn't. Note that if we are equal, then I am still a subset of him. If you want to know if I'm a strict subset, you can ask <br>	a->isSubsetOf(b) && ! a->isEqual(b)<br></font><br>Overridden by: <a href="GenericCrossRegion.html#isSubsetOf:">GenericCrossRegion</a> <a href="Filter.html#isSubsetOf:">Filter</a> <a href="IDRegion.html#isSubsetOf:">IDRegion</a> <a href="IntegerRegion.html#isSubsetOf:">IntegerRegion</a> <a href="RealRegion.html#isSubsetOf:">RealRegion</a> <a href="SequenceRegion.html#isSubsetOf:">SequenceRegion</a> <a href="SetRegion.html#isSubsetOf:">SetRegion</a> </blockquote><a name="#mapping:"><h4><font color="blue">mapping:</font> data </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#minus:"><h4><font color="blue">minus:</font> other </h4></a><blockquote><font color="green">The region containing all my position which aren't in other.<br></font><br>Overridden by: <a href="ClosedFilter.html#minus:">ClosedFilter</a> <a href="OpenFilter.html#minus:">OpenFilter</a> <a href="SetRegion.html#minus:">SetRegion</a> </blockquote><a name="#simpleRegions"><h4><font color="blue">simpleRegions</font> </h4></a><blockquote><font color="green">emulate default argument of nil<br></font></blockquote><a name="#simpleRegions:"><h4><font color="blue">simpleRegions:</font> order </h4></a><blockquote><font color="green">Break myself up into a finite set of non-empty simple regions which, when <br>	unionWith'ed together will yield me. May be sent to any region. If I <br>	am isEmpty, I will respond with the empty stepper. Otherwise, if I am <br>	simple I will respond with a stepper producing just myself. <br>	<br>	Please only use nil for the 'order' argument for now unless the <br>	documentation for a particular region or coordinate space says that <br>	it will deal with the 'order' argument meaningfully. When no order is <br>	specified then I may return the simple regions in any order. When the <br>	ordering functionality is implemented, then I am constrained to <br>	produce the simple regions in an order consistent with the argument's <br>	ordering of my positions. When the simple regions don't overlap, and <br>	don't surround each other in the ordering, then the meaning is clear. <br>	Otherwise, there are several plausible options for how we should <br>	specify this message.<br></font><br>Overridden by: <a href="CrossRegion.html#simpleRegions:">CrossRegion</a> <a href="GenericCrossRegion.html#simpleRegions:">GenericCrossRegion</a> <a href="Filter.html#simpleRegions:">Filter</a> <a href="IDRegion.html#simpleRegions:">IDRegion</a> <a href="IntegerRegion.html#simpleRegions:">IntegerRegion</a> <a href="RealRegion.html#simpleRegions:">RealRegion</a> <a href="SequenceRegion.html#simpleRegions:">SequenceRegion</a> <a href="SetRegion.html#simpleRegions:">SetRegion</a> </blockquote><a name="#simpleUnion:"><h4><font color="blue">simpleUnion:</font> other </h4></a><blockquote><font color="green">The result must contain all positions contained by either of the two <br>	original regions, and the result must be simple. However, the result <br>	may contain additional positions. See the comment on <br>	'XuRegion::asSimpleRegion'.  a->simpleUnion(b) satisfies the same specification <br>	as (a->unionWith(b))->asSimpleRegion(). However, the two results do <br>	not have to be the same region.<br></font><br>Overridden by: <a href="CrossRegion.html#simpleUnion:">CrossRegion</a> <a href="Filter.html#simpleUnion:">Filter</a> <a href="IDRegion.html#simpleUnion:">IDRegion</a> <a href="IntegerRegion.html#simpleUnion:">IntegerRegion</a> <a href="RealRegion.html#simpleUnion:">RealRegion</a> <a href="SequenceRegion.html#simpleUnion:">SequenceRegion</a> <a href="SetRegion.html#simpleUnion:">SetRegion</a> </blockquote><a name="#stepper"><h4><font color="blue">stepper</font> </h4></a><blockquote><font color="green">emulate default argument of nil<br></font></blockquote><a name="#stepper:"><h4><font color="blue">stepper:</font> order </h4></a><blockquote><font color="green">Essential.  If my positions are enumerable in the order specified, then return a stepper which will so enumerate them. If 'order' is nil, then I may treat this as a request to enumerate according to any order I choose, except that if I am enumerable in ascending order, then I must be enumerable given nil. For example, if I choose to regard nil as implying ascending order, and I am only enumerable in descending order, then given nil, I may blast even though there is an order in which I am enumerable. <br>	<br>	In fact, right now the ability to respond to an 'order' argument is in such a to-be-implemented state that it should only be considered safe to provide a nil argument, unless the documentation on a particular space or region says otherwise. <br>	<br>	The eventual specification of this message is clear, and is upwards compatible from the current behavior: If I can enumerate in an order consistent with 'order', do so. If 'order' is nil, then if I can be enumerated at all (if there is any counting sequence), then I still do so. For example, I should be able to get an (infinite) stepper for stepping through all the integers, but not all the reals. As the above example shows, being enumerable doesn't imply being finite.  <br>	<br>	Also, being able to produce a stepper that continues to yield more positions in the specified order is not sufficient to imply being enumerable.  To be enumerable, it must be the case that any given position which is a member of the region will eventually be reached by the stepper.  Not all implementations currently succeed in guaranteeing this (See UnionCrossRegion::isEnumerable).<br>	<br>	See <a href="ScruTable.html">ScruTable</a>::stepper.<br></font><br>Overridden by: <a href="RealRegion.html#stepper:">RealRegion</a> <a href="SequenceRegion.html#stepper:">SequenceRegion</a> </blockquote><a name="#theOne"><h4><font color="blue">theOne</font> </h4></a><blockquote><font color="green">Iff I contain exactly one position, return it.  Otherwise BLAST. The idea for this message is taken from the THE function of ONTIC (reference McAllester)<br></font><br>Overridden by: <a href="GenericCrossRegion.html#theOne">GenericCrossRegion</a> <a href="IDRegion.html#theOne">IDRegion</a> <a href="SetRegion.html#theOne">SetRegion</a> </blockquote><a name="#unionWith:"><h4><font color="blue">unionWith:</font> other </h4></a><blockquote><font color="green">The result has as members exactly those positions which are members of either of the original two regions. No matter how simple the two original regions are, the result may be non-simple.<br>	<br>	The only reason this is called 'unionWith' instead of 'union' is that the latter is a C++ keyword.<br></font><br>Overridden by: <a href="CrossRegion.html#unionWith:">CrossRegion</a> <a href="GenericCrossRegion.html#unionWith:">GenericCrossRegion</a> <a href="Filter.html#unionWith:">Filter</a> <a href="ClosedFilter.html#unionWith:">ClosedFilter</a> <a href="OpenFilter.html#unionWith:">OpenFilter</a> <a href="IDRegion.html#unionWith:">IDRegion</a> <a href="IntegerRegion.html#unionWith:">IntegerRegion</a> <a href="RealRegion.html#unionWith:">RealRegion</a> <a href="SequenceRegion.html#unionWith:">SequenceRegion</a> <a href="SetRegion.html#unionWith:">SetRegion</a> </blockquote><a name="#with:"><h4><font color="blue">with:</font> pos </h4></a><blockquote><font color="green">the region with one more position. Actually, if I already contain pos, then the result is just me.<br></font><br>Overridden by: <a href="IDRegion.html#with:">IDRegion</a> <a href="IntegerRegion.html#with:">IntegerRegion</a> <a href="SequenceRegion.html#with:">SequenceRegion</a> <a href="SetRegion.html#with:">SetRegion</a> </blockquote><a name="#without:"><h4><font color="blue">without:</font> pos </h4></a><blockquote><font color="green">the region with one less position. Actually if I already don't contain pos, then the result is just me.<br></font><br>Overridden by: <a href="SetRegion.html#without:">SetRegion</a> </blockquote><br><br><a href="index.html">Index</a> - <a href="AllPackages.html">All Packages</a> - <a href="AllCategories.html">All Categories</a> - <a href="AllClasses.html">All Classes</a><br></body>
</html>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5004449-1");
pageTracker._initData();
pageTracker._trackPageview();
</script>
</body>
</html>
