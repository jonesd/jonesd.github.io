<html>
<html>
<head>
<title>Class ScruTable</title>
</head><body>
<a href="index.html">Index</a> - <a href="AllPackages.html">All Packages</a> - <a href="AllCategories.html">All Categories</a> - <a href="AllClasses.html">All Classes</a><br><h1>Class ScruTable</h1>
<font color="green">Please read class comment for <a href="ScruSet.html">ScruSet</a> first.<br>	<br>	Like <a href="Set.html">Sets</a>, Tables represent collections of <a href="Heaper.html">Heapers</a>, and provide protocol for storing, retrieving, and iterating over the collection.  However, Tables in addition provide an organization for the <a href="Heaper.html">Heapers</a> collected together in the range of a Table:  A Table can also be seen as a collection of associations between keys and values.  A particular Table object has a particular domain coordinateSpace, and all keys in that Table are positions in that coordinate space.  For each position in a Table's coordinate space there is at most one value which it maps to.  This value may be any arbitrary <a href="Heaper.html">Heaper</a>.  The same <a href="Heaper.html">Heaper</a> may appear as value for several keys. <br>	<br>	When iterating over the contents of a Table with a <a href="Stepper.html">Stepper</a>, the normal elements enumerated by the <a href="Stepper.html">Stepper</a> are values (ie., range elements) of the Table.  However, <a href="ScruTable.html">ScruTable</a>::stepper returns a <a href="TableStepper.html">TableStepper</a> (a subclass of <a href="Stepper.html">Stepper</a>) which provides aditional protocol of accessing the key corresponding to the current value.  (see <a href="ScruTable.html">ScruTable</a>::stepper and <a href="TableStepper.html">TableStepper</a>.)<br></font></p>Package: <a href="Package_Udanax-Gold.html">Udanax-Gold</a><br>All Superclasses: <a href="Object.html">Object</a> <a href="Heaper.html">Heaper</a> <br>Immediate Subclasses: <a href="ImmuTable.html">ImmuTable</a> <a href="IntegerScruTable.html">IntegerScruTable</a> <a href="MuTable.html">MuTable</a> <a href="OffsetScruArray.html">OffsetScruArray</a> <a href="OffsetScruTable.html">OffsetScruTable</a> <br>Protocols: <a href="Protocol_Object.html">Object</a><br>Categories: <a href="Category_Xanadu-Collection-Tables.html">Xanadu-Collection-Tables</a><br><hr><h2>Class Methods</h3><a name="#problemsNotInTable"><h4><font color="blue">problemsNotInTable</font> </h4></a><blockquote><font color="green"><br></font></blockquote><hr><h2>Instance Methods</h3><a name="#actualHashForEqual"><h4><font color="blue">actualHashForEqual</font> </h4></a><blockquote><font color="green">See <a href="ScruTable.html">ScruTable</a>::isEqual<br></font><br>Overridden by: <a href="ImmuTable.html#actualHashForEqual">ImmuTable</a> <a href="OffsetImmuTable.html#actualHashForEqual">OffsetImmuTable</a> <a href="IntegerScruTable.html#actualHashForEqual">IntegerScruTable</a> <a href="MuTable.html#actualHashForEqual">MuTable</a> <a href="OffsetScruArray.html#actualHashForEqual">OffsetScruArray</a> <a href="OffsetScruTable.html#actualHashForEqual">OffsetScruTable</a> </blockquote><a name="#asImmuTable"><h4><font color="blue">asImmuTable</font> </h4></a><blockquote><font color="green">Return a side-effect-free snapshot of my current contents.<br>	See <a href="ScruSet.html">ScruSet</a>::asImmuSet.<br></font><br>Overridden by: <a href="ImmuTable.html#asImmuTable">ImmuTable</a> <a href="IntegerScruTable.html#asImmuTable">IntegerScruTable</a> <a href="MuTable.html#asImmuTable">MuTable</a> <a href="GrandHashTable.html#asImmuTable">GrandHashTable</a> <a href="OffsetScruArray.html#asImmuTable">OffsetScruArray</a> <a href="OffsetScruTable.html#asImmuTable">OffsetScruTable</a> </blockquote><a name="#asMuTable"><h4><font color="blue">asMuTable</font> </h4></a><blockquote><font color="green">Return a side-effectable version of the same table.<br>	See <a href="ScruSet.html">ScruSet</a>::asMuSet.<br></font><br>Overridden by: <a href="ImmuTable.html#asMuTable">ImmuTable</a> <a href="ImmuTableOnMu.html#asMuTable">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#asMuTable">OffsetImmuTable</a> <a href="IntegerScruTable.html#asMuTable">IntegerScruTable</a> <a href="MuTable.html#asMuTable">MuTable</a> <a href="GrandHashTable.html#asMuTable">GrandHashTable</a> <a href="OffsetScruArray.html#asMuTable">OffsetScruArray</a> <a href="OffsetScruTable.html#asMuTable">OffsetScruTable</a> </blockquote><a name="#asOrderedCollection"><h4><font color="blue">asOrderedCollection</font> </h4></a><blockquote><font color="green">convert for use with Smalltalk MVC stuff<br></font></blockquote><a name="#backfollowFrom:"><h4><font color="blue">backfollowFrom:</font> value </h4></a><blockquote><font color="green">Return the subTable with the domain of all positions whose values are equal to <br>	value.  Defined by analogy with corresponding Waldo-level operation.<br></font></blockquote><a name="#contentsEqual:"><h4><font color="blue">contentsEqual:</font> other </h4></a><blockquote><font color="green">Returns whether the two <a href="ScruTable.html">ScruTables</a> have exactly the same mapping from <br>	keys to values at the moment. 'a->contentsEqual(b)' is equivalent to <br>	'a->asImmuTable()->isEqual(b->asImmuTable())'. See <a href="ScruTable.html">ScruTable</a>::contentsEqual<br></font></blockquote><a name="#contentsHash"><h4><font color="blue">contentsHash</font> </h4></a><blockquote><font color="green">Has the same relationship to contentsEqual that hashForEqual has to isEqual. <br>	Ie., if 'a->contentsEqual (b)', then 'a->contentsHash() == b->contentsHash()'. <br>	The same complex caveats apply as to the stability and portability of the <br>	hash values as apply for hashForEqual.  See <a href="ScruSet.html">ScruSet</a> contentsHash.<br></font></blockquote><a name="#coordinateSpace"><h4><font color="blue">coordinateSpace</font> </h4></a><blockquote><font color="green">The kind of elements used to index into the table are <a href="Position.html">Positions</a> of this <br>	coordinate space. Therefore, the domain of this table is an XuRegion in this <br>	coordinate space.<br></font><br>Overridden by: <a href="ImmuTable.html#coordinateSpace">ImmuTable</a> <a href="ImmuTableOnMu.html#coordinateSpace">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#coordinateSpace">OffsetImmuTable</a> <a href="IntegerScruTable.html#coordinateSpace">IntegerScruTable</a> <a href="MuTable.html#coordinateSpace">MuTable</a> <a href="GrandHashTable.html#coordinateSpace">GrandHashTable</a> <a href="HashTable.html#coordinateSpace">HashTable</a> <a href="ActualHashTable.html#coordinateSpace">ActualHashTable</a> <a href="IntegerTable.html#coordinateSpace">IntegerTable</a> <a href="MuArray.html#coordinateSpace">MuArray</a> <a href="ActualArray.html#coordinateSpace">ActualArray</a> <a href="OberIntegerTable.html#coordinateSpace">OberIntegerTable</a> <a href="ActualIntegerTable.html#coordinateSpace">ActualIntegerTable</a> <a href="COWIntegerTable.html#coordinateSpace">COWIntegerTable</a> <a href="OffsetScruArray.html#coordinateSpace">OffsetScruArray</a> <a href="OffsetScruTable.html#coordinateSpace">OffsetScruTable</a> </blockquote><a name="#copy"><h4><font color="blue">copy</font> </h4></a><blockquote><font color="green">A new one whose initial state is my current state, but that doesn't track <br>	changes. Note that there is no implication that these can be 'destroy'ed <br>	separately, because (for example) an <a href="ImmuTable.html">ImmuTable</a> just returns itself<br></font><br>Overrides: <a href="Object.html#copy">Object</a><br>Overridden by: <a href="ImmuTable.html#copy">ImmuTable</a> <a href="IntegerScruTable.html#copy">IntegerScruTable</a> <a href="MuTable.html#copy">MuTable</a> <a href="GrandHashTable.html#copy">GrandHashTable</a> <a href="HashTable.html#copy">HashTable</a> <a href="ActualHashTable.html#copy">ActualHashTable</a> <a href="IntegerTable.html#copy">IntegerTable</a> <a href="MuArray.html#copy">MuArray</a> <a href="ActualArray.html#copy">ActualArray</a> <a href="OberIntegerTable.html#copy">OberIntegerTable</a> <a href="ActualIntegerTable.html#copy">ActualIntegerTable</a> <a href="COWIntegerTable.html#copy">COWIntegerTable</a> <a href="OffsetScruArray.html#copy">OffsetScruArray</a> <a href="OffsetScruTable.html#copy">OffsetScruTable</a> </blockquote><a name="#count"><h4><font color="blue">count</font> </h4></a><blockquote><font color="green">Return the number of domain elements, which is to say, the number of associations.<br>	'table->count()' should be equivalent to 'table->domain()->count()'.<br>	<br>	Used to say: 'Return the number of range elements'.  This seems clearly wrong.<br></font><br>Overridden by: <a href="ImmuTable.html#count">ImmuTable</a> <a href="ImmuTableOnMu.html#count">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#count">OffsetImmuTable</a> <a href="IntegerScruTable.html#count">IntegerScruTable</a> <a href="MuTable.html#count">MuTable</a> <a href="GrandHashTable.html#count">GrandHashTable</a> <a href="HashTable.html#count">HashTable</a> <a href="ActualHashTable.html#count">ActualHashTable</a> <a href="IntegerTable.html#count">IntegerTable</a> <a href="MuArray.html#count">MuArray</a> <a href="ActualArray.html#count">ActualArray</a> <a href="OberIntegerTable.html#count">OberIntegerTable</a> <a href="ActualIntegerTable.html#count">ActualIntegerTable</a> <a href="COWIntegerTable.html#count">COWIntegerTable</a> <a href="OffsetScruArray.html#count">OffsetScruArray</a> <a href="OffsetScruTable.html#count">OffsetScruTable</a> </blockquote><a name="#create"><h4><font color="blue">create</font> </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="Heaper.html#create">Heaper</a><br>Overridden by: <a href="MuTable.html#create">MuTable</a> <a href="HashTable.html#create">HashTable</a> <a href="IntegerTable.html#create">IntegerTable</a> <a href="ActualArray.html#create">ActualArray</a> <a href="OberIntegerTable.html#create">OberIntegerTable</a> <a href="ActualIntegerTable.html#create">ActualIntegerTable</a> </blockquote><a name="#do:"><h4><font color="blue">do:</font> aBlock </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#domain"><h4><font color="blue">domain</font> </h4></a><blockquote><font color="green">Return an XuRegion representing a snapshot of the current domain.  <br>	'table->domain()->hasMember(p)' iff 'table->fetch(p) != nil'.<br></font><br>Overridden by: <a href="ImmuTable.html#domain">ImmuTable</a> <a href="ImmuTableOnMu.html#domain">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#domain">OffsetImmuTable</a> <a href="IntegerScruTable.html#domain">IntegerScruTable</a> <a href="MuTable.html#domain">MuTable</a> <a href="GrandHashTable.html#domain">GrandHashTable</a> <a href="HashTable.html#domain">HashTable</a> <a href="ActualHashTable.html#domain">ActualHashTable</a> <a href="IntegerTable.html#domain">IntegerTable</a> <a href="MuArray.html#domain">MuArray</a> <a href="ActualArray.html#domain">ActualArray</a> <a href="OberIntegerTable.html#domain">OberIntegerTable</a> <a href="ActualIntegerTable.html#domain">ActualIntegerTable</a> <a href="COWIntegerTable.html#domain">COWIntegerTable</a> <a href="OffsetScruArray.html#domain">OffsetScruArray</a> <a href="OffsetScruTable.html#domain">OffsetScruTable</a> </blockquote><a name="#emptySize:"><h4><font color="blue">emptySize:</font> size </h4></a><blockquote><font color="green">Return an empty table just like the current one. The 'size' argument is a hint <br>	about how big the count of the table will probably become (so that the new <br>	table can be prepared to grow to that size efficiently).<br></font><br>Overridden by: <a href="ImmuTable.html#emptySize:">ImmuTable</a> <a href="ImmuTableOnMu.html#emptySize:">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#emptySize:">OffsetImmuTable</a> <a href="IntegerScruTable.html#emptySize:">IntegerScruTable</a> <a href="MuTable.html#emptySize:">MuTable</a> <a href="GrandHashTable.html#emptySize:">GrandHashTable</a> <a href="HashTable.html#emptySize:">HashTable</a> <a href="ActualHashTable.html#emptySize:">ActualHashTable</a> <a href="IntegerTable.html#emptySize:">IntegerTable</a> <a href="MuArray.html#emptySize:">MuArray</a> <a href="ActualArray.html#emptySize:">ActualArray</a> <a href="OberIntegerTable.html#emptySize:">OberIntegerTable</a> <a href="ActualIntegerTable.html#emptySize:">ActualIntegerTable</a> <a href="COWIntegerTable.html#emptySize:">COWIntegerTable</a> <a href="OffsetScruArray.html#emptySize:">OffsetScruArray</a> <a href="OffsetScruTable.html#emptySize:">OffsetScruTable</a> </blockquote><a name="#fetch:"><h4><font color="blue">fetch:</font> key </h4></a><blockquote><font color="green">Return the range element at the domain position key. The routine will return <br>	nil if the position is not in the table.<br></font><br>Overridden by: <a href="ImmuTable.html#fetch:">ImmuTable</a> <a href="ImmuTableOnMu.html#fetch:">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#fetch:">OffsetImmuTable</a> <a href="IntegerScruTable.html#fetch:">IntegerScruTable</a> <a href="MuTable.html#fetch:">MuTable</a> <a href="GrandHashTable.html#fetch:">GrandHashTable</a> <a href="HashTable.html#fetch:">HashTable</a> <a href="ActualHashTable.html#fetch:">ActualHashTable</a> <a href="IntegerTable.html#fetch:">IntegerTable</a> <a href="MuArray.html#fetch:">MuArray</a> <a href="ActualArray.html#fetch:">ActualArray</a> <a href="OberIntegerTable.html#fetch:">OberIntegerTable</a> <a href="ActualIntegerTable.html#fetch:">ActualIntegerTable</a> <a href="COWIntegerTable.html#fetch:">COWIntegerTable</a> <a href="OffsetScruArray.html#fetch:">OffsetScruArray</a> <a href="OffsetScruTable.html#fetch:">OffsetScruTable</a> </blockquote><a name="#get:"><h4><font color="blue">get:</font> key </h4></a><blockquote><font color="green">Return the range element at the domain position key. BLAST if the position is <br>	not in the table.<br></font></blockquote><a name="#includesIntKey:"><h4><font color="blue">includesIntKey:</font> aKey </h4></a><blockquote><font color="green">Unboxed version.  See class comment for XuInteger<br></font><br>Overridden by: <a href="ImmuTable.html#includesIntKey:">ImmuTable</a> <a href="ImmuTableOnMu.html#includesIntKey:">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#includesIntKey:">OffsetImmuTable</a> <a href="IntegerScruTable.html#includesIntKey:">IntegerScruTable</a> <a href="MuTable.html#includesIntKey:">MuTable</a> <a href="GrandHashTable.html#includesIntKey:">GrandHashTable</a> <a href="IntegerTable.html#includesIntKey:">IntegerTable</a> <a href="MuArray.html#includesIntKey:">MuArray</a> <a href="OberIntegerTable.html#includesIntKey:">OberIntegerTable</a> <a href="ActualIntegerTable.html#includesIntKey:">ActualIntegerTable</a> <a href="COWIntegerTable.html#includesIntKey:">COWIntegerTable</a> <a href="OffsetScruArray.html#includesIntKey:">OffsetScruArray</a> <a href="OffsetScruTable.html#includesIntKey:">OffsetScruTable</a> </blockquote><a name="#includesKey:"><h4><font color="blue">includesKey:</font> key </h4></a><blockquote><font color="green">includesKey is used to test for the presence of a key->value pair in the<br>	table.  This routine returns true if there is a value present at the specified<br>	key, and false otherwise.<br>	'table->includesKey(p)' iff 'table->domain()->hasMember(p)'.<br></font><br>Overridden by: <a href="ImmuTable.html#includesKey:">ImmuTable</a> <a href="ImmuTableOnMu.html#includesKey:">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#includesKey:">OffsetImmuTable</a> <a href="IntegerScruTable.html#includesKey:">IntegerScruTable</a> <a href="MuTable.html#includesKey:">MuTable</a> <a href="GrandHashTable.html#includesKey:">GrandHashTable</a> <a href="HashTable.html#includesKey:">HashTable</a> <a href="ActualHashTable.html#includesKey:">ActualHashTable</a> <a href="IntegerTable.html#includesKey:">IntegerTable</a> <a href="MuArray.html#includesKey:">MuArray</a> <a href="OberIntegerTable.html#includesKey:">OberIntegerTable</a> <a href="ActualIntegerTable.html#includesKey:">ActualIntegerTable</a> <a href="COWIntegerTable.html#includesKey:">COWIntegerTable</a> <a href="OffsetScruArray.html#includesKey:">OffsetScruArray</a> <a href="OffsetScruTable.html#includesKey:">OffsetScruTable</a> </blockquote><a name="#intFetch:"><h4><font color="blue">intFetch:</font> key </h4></a><blockquote><font color="green">Unboxed version.  See class comment for XuInteger<br></font><br>Overridden by: <a href="ImmuTable.html#intFetch:">ImmuTable</a> <a href="ImmuTableOnMu.html#intFetch:">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#intFetch:">OffsetImmuTable</a> <a href="IntegerScruTable.html#intFetch:">IntegerScruTable</a> <a href="MuTable.html#intFetch:">MuTable</a> <a href="ActualHashTable.html#intFetch:">ActualHashTable</a> <a href="IntegerTable.html#intFetch:">IntegerTable</a> <a href="MuArray.html#intFetch:">MuArray</a> <a href="ActualArray.html#intFetch:">ActualArray</a> <a href="OberIntegerTable.html#intFetch:">OberIntegerTable</a> <a href="ActualIntegerTable.html#intFetch:">ActualIntegerTable</a> <a href="COWIntegerTable.html#intFetch:">COWIntegerTable</a> <a href="OffsetScruArray.html#intFetch:">OffsetScruArray</a> <a href="OffsetScruTable.html#intFetch:">OffsetScruTable</a> </blockquote><a name="#intGet:"><h4><font color="blue">intGet:</font> key </h4></a><blockquote><font color="green">Unboxed version.  See class comment for XuInteger<br></font></blockquote><a name="#isEmpty"><h4><font color="blue">isEmpty</font> </h4></a><blockquote><font color="green">Is there anything in the table? <br>	'table->isEmpty()' iff 'table->domain()->isEmpty()'.<br></font><br>Overridden by: <a href="ImmuTable.html#isEmpty">ImmuTable</a> <a href="ImmuTableOnMu.html#isEmpty">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#isEmpty">OffsetImmuTable</a> <a href="IntegerScruTable.html#isEmpty">IntegerScruTable</a> <a href="MuTable.html#isEmpty">MuTable</a> <a href="GrandHashTable.html#isEmpty">GrandHashTable</a> <a href="HashTable.html#isEmpty">HashTable</a> <a href="ActualHashTable.html#isEmpty">ActualHashTable</a> <a href="IntegerTable.html#isEmpty">IntegerTable</a> <a href="MuArray.html#isEmpty">MuArray</a> <a href="ActualArray.html#isEmpty">ActualArray</a> <a href="OberIntegerTable.html#isEmpty">OberIntegerTable</a> <a href="ActualIntegerTable.html#isEmpty">ActualIntegerTable</a> <a href="COWIntegerTable.html#isEmpty">COWIntegerTable</a> <a href="OffsetScruArray.html#isEmpty">OffsetScruArray</a> <a href="OffsetScruTable.html#isEmpty">OffsetScruTable</a> </blockquote><a name="#isEqual:"><h4><font color="blue">isEqual:</font> other </h4></a><blockquote><font color="green">All <a href="MuTable.html">MuTable</a> subclasses have equality based on identity <br>	(now and forever equal. Many <a href="ScruTable.html">ScruTable</a> subclasses will <br>	represent an aspect of another table. Therefore they have <br>	hashForEqual and isEqual: based on both their contained <br>	table, and the aspect that they represent. Thus, two similar <br>	views onto the same <a href="MuTable.html">MuTable</a> are now (and forever) equal. <br>	The hashForEqual: must use exactly the same aspects for <br>	the hash as get used for isEqual:. <a href="ImmuTable.html">ImmuTables</a> all use <br>	contentBased comparison operations.<br></font><br>Overridden by: <a href="ImmuTable.html#isEqual:">ImmuTable</a> <a href="IntegerScruTable.html#isEqual:">IntegerScruTable</a> <a href="MuTable.html#isEqual:">MuTable</a> <a href="OffsetScruArray.html#isEqual:">OffsetScruArray</a> <a href="OffsetScruTable.html#isEqual:">OffsetScruTable</a> </blockquote><a name="#printOn:"><h4><font color="blue">printOn:</font> stream </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="Object.html#printOn:">Object</a><br>Overridden by: <a href="ImmuTableOnMu.html#printOn:">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#printOn:">OffsetImmuTable</a> <a href="GrandHashTable.html#printOn:">GrandHashTable</a> <a href="ActualHashTable.html#printOn:">ActualHashTable</a> <a href="ActualArray.html#printOn:">ActualArray</a> <a href="ActualIntegerTable.html#printOn:">ActualIntegerTable</a> <a href="OffsetScruArray.html#printOn:">OffsetScruArray</a> <a href="OffsetScruTable.html#printOn:">OffsetScruTable</a> </blockquote><a name="#printOnWithSimpleSyntax:with:with:with:"><h4><font color="blue">printOnWithSimpleSyntax:</font> oo <font color="blue">with:</font> open <font color="blue">with:</font> sep <font color="blue">with:</font> close </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#printOnWithSyntax:with:with:with:with:"><h4><font color="blue">printOnWithSyntax:</font> stream <font color="blue">with:</font> open <font color="blue">with:</font> map <font color="blue">with:</font> sep <font color="blue">with:</font> close </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#range"><h4><font color="blue">range</font> </h4></a><blockquote><font color="green">A snapshot of the current range elements of the table collected together into <br>	an <a href="ImmuSet.html">ImmuSet</a>.<br></font></blockquote><a name="#runAt:"><h4><font color="blue">runAt:</font> key </h4></a><blockquote><font color="green">Return the length of the run starting at position key. A run is defined as a <br>	contiguous (charming) sequence of domain positions mapping to equal (isEqual) <br>	objects. Charming is defined as: Given a charming region R, for all a,c which <br>	are elements of R and a >= b >= c, b is an element of R. Where '>=' is <br>	according to the 'isGE' message. <br>	<br>	NOTE: We may retire the above definition of charming. The possible changes <br>	will only effect spaces which aren't fully ordered. OrderedRegions, <br>	TreeRegions, and <a href="IntegerRegion.html">IntegerRegions</a> will be unaffected, as any future definition of <br>	'runAt' will be equivalent for them.<br></font><br>Overridden by: <a href="ImmuTable.html#runAt:">ImmuTable</a> <a href="ImmuTableOnMu.html#runAt:">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#runAt:">OffsetImmuTable</a> <a href="IntegerScruTable.html#runAt:">IntegerScruTable</a> <a href="MuTable.html#runAt:">MuTable</a> <a href="GrandHashTable.html#runAt:">GrandHashTable</a> <a href="HashTable.html#runAt:">HashTable</a> <a href="ActualHashTable.html#runAt:">ActualHashTable</a> <a href="IntegerTable.html#runAt:">IntegerTable</a> <a href="MuArray.html#runAt:">MuArray</a> <a href="ActualArray.html#runAt:">ActualArray</a> <a href="OberIntegerTable.html#runAt:">OberIntegerTable</a> <a href="ActualIntegerTable.html#runAt:">ActualIntegerTable</a> <a href="COWIntegerTable.html#runAt:">COWIntegerTable</a> <a href="OffsetScruArray.html#runAt:">OffsetScruArray</a> <a href="OffsetScruTable.html#runAt:">OffsetScruTable</a> </blockquote><a name="#runAtInt:"><h4><font color="blue">runAtInt:</font> key </h4></a><blockquote><font color="green">Unboxed version.  See class comment for XuInteger<br></font><br>Overridden by: <a href="ImmuTable.html#runAtInt:">ImmuTable</a> <a href="ImmuTableOnMu.html#runAtInt:">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#runAtInt:">OffsetImmuTable</a> <a href="IntegerScruTable.html#runAtInt:">IntegerScruTable</a> <a href="MuTable.html#runAtInt:">MuTable</a> <a href="GrandHashTable.html#runAtInt:">GrandHashTable</a> <a href="IntegerTable.html#runAtInt:">IntegerTable</a> <a href="MuArray.html#runAtInt:">MuArray</a> <a href="ActualArray.html#runAtInt:">ActualArray</a> <a href="OberIntegerTable.html#runAtInt:">OberIntegerTable</a> <a href="ActualIntegerTable.html#runAtInt:">ActualIntegerTable</a> <a href="COWIntegerTable.html#runAtInt:">COWIntegerTable</a> <a href="OffsetScruArray.html#runAtInt:">OffsetScruArray</a> <a href="OffsetScruTable.html#runAtInt:">OffsetScruTable</a> </blockquote><a name="#stepper"><h4><font color="blue">stepper</font> </h4></a><blockquote><font color="green">implement default argument of nil<br></font><br>Overridden by: <a href="OffsetImmuTable.html#stepper">OffsetImmuTable</a> <a href="OffsetScruArray.html#stepper">OffsetScruArray</a> <a href="OffsetScruTable.html#stepper">OffsetScruTable</a> </blockquote><a name="#stepper:"><h4><font color="blue">stepper:</font> order </h4></a><blockquote><font color="green">Return a <a href="TableStepper.html">TableStepper</a> which will enumerate my key->value mappings. The <br>	<a href="Stepper.html">Stepper</a> component of the <a href="TableStepper.html">TableStepper</a> protocol will just enumerate my values <br>	(as that is what I'm a container *of*--the keys are simply how I organize my <br>	contents). <a href="TableStepper.html">TableStepper</a> provides additional protocol to ascetain the current <br>	key. See <a href="TableStepper.html">TableStepper</a> and XuRegion::stepper. The <a href="TableStepper.html">TableStepper</a> I produce given <br>	an order must enumerate keys according to the same rules which specify how <br>	XuRegion::stepper must enumerate positions. I am not asserting that the actual <br>	orders are the same, only that the correctness criteria on the allowable orders <br>	are the same. <br>	<br>	Keeping in mind that we are talking about equivalence of specification <br>	and not equivalence of particular behavior, the following two statements <br>	are equivalent: <br><br>	{<br>		SPTR(<a href="TableStepper.html">TableStepper</a>) stomp = table->stepper(o);<br>		SPTR(<a href="Position.html">Position</a>) key;<br>		FOR_EACH(<a href="Heaper.html">Heaper</a>,val,stomp, {<br>			key = stomp->key();<br>			doSomethingWith(key, val);<br>		});<br>	}<br>	<br>	and<br>	<br>	{<br>		SPTR(<a href="Heaper.html">Heaper</a>) val;<br>		SPTR(<a href="ImmuTable.html">ImmuTable</a>) snapShot = table->asImmuTable();<br>		FOR_EACH(<a href="Position.html">Position</a>,key,(snapShot->domain()->stepper(o)), {<br>			val = snapShot->get (key);<br>			doSomethingWith(key, val);<br>		});<br>	}<br>			<br>	<br></font><br>Overridden by: <a href="ImmuTable.html#stepper:">ImmuTable</a> <a href="ImmuTableOnMu.html#stepper:">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#stepper:">OffsetImmuTable</a> <a href="IntegerScruTable.html#stepper:">IntegerScruTable</a> <a href="MuTable.html#stepper:">MuTable</a> <a href="GrandHashTable.html#stepper:">GrandHashTable</a> <a href="HashTable.html#stepper:">HashTable</a> <a href="ActualHashTable.html#stepper:">ActualHashTable</a> <a href="IntegerTable.html#stepper:">IntegerTable</a> <a href="MuArray.html#stepper:">MuArray</a> <a href="ActualArray.html#stepper:">ActualArray</a> <a href="OberIntegerTable.html#stepper:">OberIntegerTable</a> <a href="ActualIntegerTable.html#stepper:">ActualIntegerTable</a> <a href="COWIntegerTable.html#stepper:">COWIntegerTable</a> <a href="OffsetScruArray.html#stepper:">OffsetScruArray</a> <a href="OffsetScruTable.html#stepper:">OffsetScruTable</a> </blockquote><a name="#subTable:"><h4><font color="blue">subTable:</font> region </h4></a><blockquote><font color="green">Return a table which contains only the intersection of this table's domain and <br>	the domain specified by 'region'. <br>	table->subTable(r)->domain()->isEqual( table->domain()->intersect(r) ). <br>	<br>	It is unspecified whether the resulting table starts as a snapshot of a subset of <br>	me, after which we go our own ways; or whether the resulting table is a view <br>	onto a subset of me, such that changes to me are also visible to him. Of <br>	course, subclasses may specify more. If you want to ensure snapshot behavior, <br>	do 'table->subTable(r)->asImmuTable()'. <br>	<br>	NOTE: In the future we may specify snapshot behavior or we may specify view <br>	behavior. As a client this shouldn't effect you. However, if you implement a <br>	new kind of <a href="ScruTable.html">ScruTable</a>, please let us know. Also, if you have an opinion as to <br>	which way you'd like the specification tightened up, please tell us.<br></font><br>Overridden by: <a href="ImmuTable.html#subTable:">ImmuTable</a> <a href="ImmuTableOnMu.html#subTable:">ImmuTableOnMu</a> <a href="OffsetImmuTable.html#subTable:">OffsetImmuTable</a> <a href="IntegerScruTable.html#subTable:">IntegerScruTable</a> <a href="MuTable.html#subTable:">MuTable</a> <a href="GrandHashTable.html#subTable:">GrandHashTable</a> <a href="HashTable.html#subTable:">HashTable</a> <a href="ActualHashTable.html#subTable:">ActualHashTable</a> <a href="IntegerTable.html#subTable:">IntegerTable</a> <a href="MuArray.html#subTable:">MuArray</a> <a href="ActualArray.html#subTable:">ActualArray</a> <a href="OberIntegerTable.html#subTable:">OberIntegerTable</a> <a href="ActualIntegerTable.html#subTable:">ActualIntegerTable</a> <a href="COWIntegerTable.html#subTable:">COWIntegerTable</a> <a href="OffsetScruArray.html#subTable:">OffsetScruArray</a> <a href="OffsetScruTable.html#subTable:">OffsetScruTable</a> </blockquote><a name="#theOne"><h4><font color="blue">theOne</font> </h4></a><blockquote><font color="green">Iff I contain exactly one range element, return it.  Otherwise BLAST.<br>	The idea for this message is taken from the THE function of ONTIC<br>	(reference McAllester)<br></font><br>Overridden by: <a href="ImmuTableOnMu.html#theOne">ImmuTableOnMu</a> <a href="HashTable.html#theOne">HashTable</a> <a href="ActualHashTable.html#theOne">ActualHashTable</a> <a href="MuArray.html#theOne">MuArray</a> <a href="ActualIntegerTable.html#theOne">ActualIntegerTable</a> </blockquote><a name="#transformedBy:"><h4><font color="blue">transformedBy:</font> dsp </h4></a><blockquote><font color="green">Return a <a href="ScruTable.html">ScruTable</a> with the domain of the receiver transformed by the <a href="Dsp.html">Dsp</a>. <br>	'table->transformedBy(d)->fetch(p)' is equivalent to <br>	'table->fetch(d->of(p))'. <br>	<br>	See <a href="ScruTable.html">ScruTable</a>::subTable for caveats regarding whether we return a snapshot <br>	or a view. All the same caveats apply.<br></font><br>Overridden by: <a href="ImmuTable.html#transformedBy:">ImmuTable</a> <a href="OffsetImmuTable.html#transformedBy:">OffsetImmuTable</a> <a href="MuArray.html#transformedBy:">MuArray</a> <a href="OffsetScruArray.html#transformedBy:">OffsetScruArray</a> <a href="OffsetScruTable.html#transformedBy:">OffsetScruTable</a> </blockquote><br><br><a href="index.html">Index</a> - <a href="AllPackages.html">All Packages</a> - <a href="AllCategories.html">All Categories</a> - <a href="AllClasses.html">All Classes</a><br></body>
</html>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5004449-1");
pageTracker._initData();
pageTracker._trackPageview();
</script>
</body>
</html>
