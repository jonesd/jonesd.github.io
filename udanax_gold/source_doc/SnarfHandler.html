<html>
<html>
<head>
<title>Class SnarfHandler</title>
</head><body>
<a href="index.html">Index</a> - <a href="AllPackages.html">All Packages</a> - <a href="AllCategories.html">All Categories</a> - <a href="AllClasses.html">All Classes</a><br><h1>Class SnarfHandler</h1>
<font color="green">A <a href="SnarfHandler.html">SnarfHandler</a> breaks a snarf into abstract subarrays of bytes into whic flocks are stored.  These indexed flock storage areas are accessed through readStreams and writeStreams provided by the <a href="SnarfHandler.html">SnarfHandler</a>.  <a href="SnarfHandler.html">SnarfHandlers</a> also provide the ability to resize these flock areas and associate a couple of flag bits with them.  All access to the snarf goes through a single snarfHandler.<br><br>The beginning of the snarf is dedicated to a table that describes the locations and sizes of the contained flock areas.  Currently, we allocate space between the flock nearest the front of the snarf and the end of the mapTable.  When not enough space exists between the two, we compact the flock storage areas towards the back (highest address) of the snarf and try to allocate again.<br><br>An index in the snarfHAndler can be associated either with one of these flock storage areas or with a snarfID and index to look further for the storage of a given flock.  Right now, the SnarfHAndler keeps the forwarding information in a flock storage area, but it will soon be put into the mapTable directly.<br><br>Forwarding pointers occur when a flock outgrows a snarf, and must be moved elsewhere.  Eventually all other snarfs that have objects which point to the forwarding pointer are updated, and the forwarding pointer can be deallocated, but decisions about this must be made by objects external to the <a href="SnarfHandler.html">SnarfHandler</a>.<br><br>The forwarded flag is stored on the snarfID.  The forgotten flag is stored on the size.  Both use the same Flag mask for accessing the flag, and the Value mask for accessing the value.<br></font></p>Package: <a href="Package_Udanax-Gold.html">Udanax-Gold</a><br>All Superclasses: <a href="Object.html">Object</a> <a href="Heaper.html">Heaper</a> <br>Protocols: <a href="Protocol_Object.html">Object</a><br>Categories: <a href="Category_Xanadu-Snarf.html">Xanadu-Snarf</a><br><hr><h2>Class Methods</h3><a name="#fenceSize"><h4><font color="blue">fenceSize</font> </h4></a><blockquote><font color="green">The number of bytes for one fence (Each flock requires two).<br></font></blockquote><a name="#linkTimeNonInherited"><h4><font color="blue">linkTimeNonInherited</font> </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#make:"><h4><font color="blue">make:</font> snarfHandle </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#mapCellOverhead"><h4><font color="blue">mapCellOverhead</font> </h4></a><blockquote><font color="green">Return the number of bytes for a single map record, plus the space for the <br>	fence. The fence will be just the index of the flock stored at the beginning and <br>	the end of the flock's memory<br></font></blockquote><a name="#mapCellSize"><h4><font color="blue">mapCellSize</font> </h4></a><blockquote><font color="green">Return the number of bytes for a single map record.<br></font></blockquote><a name="#mapOverhead"><h4><font color="blue">mapOverhead</font> </h4></a><blockquote><font color="green">The map starts just after the basic header.  The basic header currently has<br>	 the number of entries in the map and total amount of free space remaining.<br></font></blockquote><a name="#quickSort:with:with:with:"><h4><font color="blue">quickSort:</font> offsets <font color="blue">with:</font> indices <font color="blue">with:</font> first <font color="blue">with:</font> last </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#quickSort:with:with:with:with:"><h4><font color="blue">quickSort:</font> offsets <font color="blue">with:</font> indices <font color="blue">with:</font> os <font color="blue">with:</font> first <font color="blue">with:</font> last </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#sort:"><h4><font color="blue">sort:</font> offsets </h4></a><blockquote><font color="green">Sort the offsets array in place, and return an array of the same size that maps from the new index of each element to its original index.  The offsets array is *assumed* to be terminated with a guard element which is greater than or equal to all the other elements of the array according to descending order.  If this isn't true, havoc may result.<br></font></blockquote><a name="#sort:with:"><h4><font color="blue">sort:</font> offsets <font color="blue">with:</font> os </h4></a><blockquote><font color="green">Sort the offsets array in place, and return an array of the same size that maps from the new index of each element to its original index.  The offsets array is *assumed* to be terminated with a guard element which is greater than or equal to all the other elements of the array according to the sorting order.  If this isn't true, havoc may result.<br></font></blockquote><a name="#sortTest:"><h4><font color="blue">sortTest:</font> array </h4></a><blockquote><font color="green">self sortTest: <a href="SnarfHandler.html#">#</a>(2 3 4 1).<br>	self sortTest: <a href="SnarfHandler.html#">#</a>().<br>	self sortTest: <a href="SnarfHandler.html#">#</a>(1000 1000 1000).<br>	self sortTest: <a href="SnarfHandler.html#">#</a>(1 2 3 4).<br>	self sortTest: <a href="SnarfHandler.html#">#</a>(1).<br>	self sortTest: <a href="SnarfHandler.html#">#</a>(2 2 3 3 4 4 1 1).<br></font></blockquote><a name="#sortTestDown:"><h4><font color="blue">sortTestDown:</font> array </h4></a><blockquote><font color="green">self sortTestDown: <a href="SnarfHandler.html#">#</a>(2 3 4 1).<br>	self sortTestDown: <a href="SnarfHandler.html#">#</a>().<br>	self sortTestDown: <a href="SnarfHandler.html#">#</a>(1000 1000 1000).<br>	self sortTestDown: <a href="SnarfHandler.html#">#</a>(1 2 3 4).<br>	self sortTestDown: <a href="SnarfHandler.html#">#</a>(1).<br>	self sortTestDown: <a href="SnarfHandler.html#">#</a>(2 2 3 3 4 4 1 1).<br></font></blockquote><a name="#swap:with:with:"><h4><font color="blue">swap:</font> array <font color="blue">with:</font> i <font color="blue">with:</font> j </h4></a><blockquote><font color="green"><br></font></blockquote><hr><h2>Instance Methods</h3><a name="#actualHashForEqual"><h4><font color="blue">actualHashForEqual</font> </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#allocateCells:"><h4><font color="blue">allocateCells:</font> indices </h4></a><blockquote><font color="green">Add more cells to the mapTable.  Make sure that there is enough space for<br>	 those cells, then initialize.  The size is initially 0 and the offset points past <br>	 the end of the snarf.<br></font></blockquote><a name="#at:allocate:"><h4><font color="blue">at:</font> ind <font color="blue">allocate:</font> flockSize </h4></a><blockquote><font color="green">Allocate flockSize bytes for the flock at the index ind.<br></font></blockquote><a name="#at:storeForget:"><h4><font color="blue">at:</font> index <font color="blue">storeForget:</font> flag </h4></a><blockquote><font color="green">See the comment on isForgotten:.  <a href="Set.html">Set</a> or clear the forgetFlag for the flock at index.<br></font></blockquote><a name="#at:storeIndex:"><h4><font color="blue">at:</font> index <font color="blue">storeIndex:</font> offset </h4></a><blockquote><font color="green">Store the offset as the starting location for the data of the flock at index.  <br>	 Update the cache of nearestFlock.  This also clears the forwarded flag.<br></font></blockquote><a name="#at:storeSize:"><h4><font color="blue">at:</font> index <font color="blue">storeSize:</font> size </h4></a><blockquote><font color="green">Store size as the number of bytes for the flock at index.  If the <br>	 space is at a 0, then change the corresponding pointer to past the end of <br>	 the snarf so that we don't find it in our searches.<br></font></blockquote><a name="#checkFence:"><h4><font color="blue">checkFence:</font> index </h4></a><blockquote><font color="green">If we are using fences around flock storage areas, then return true only if the fences are still in place for the flock at index.  Fences are extra storage at the front and back of a flock storage area that contains the index of that flock.  These are used for runtime checks that one flock hasn't stepped into the space of another.<br></font></blockquote><a name="#checkFences"><h4><font color="blue">checkFences</font> </h4></a><blockquote><font color="green">See checkFence:  Check the fences for all flocks and blast if any are violated.<br></font></blockquote><a name="#checkIndex:"><h4><font color="blue">checkIndex:</font> index </h4></a><blockquote><font color="green">Blast if the index is not represented in the table.  This is just simple bounds checking.<br></font></blockquote><a name="#clearSpace:"><h4><font color="blue">clearSpace:</font> count </h4></a><blockquote><font color="green">This checks for count bytes available at the end of the mapTable.  If<br>	 there isn't enough, it compacts everything and tries again.<br></font></blockquote><a name="#compact"><h4><font color="blue">compact</font> </h4></a><blockquote><font color="green">Compress flock storage areas towards the end of the snarf, leaving all<br>	 freespace between the end of the mapTable and the nearest flock.<br></font></blockquote><a name="#consistencyCheck"><h4><font color="blue">consistencyCheck</font> </h4></a><blockquote><font color="green">Generic checking hook to do slow runtime consistency checking when debugging.  No checks are active currently.<br></font></blockquote><a name="#create:"><h4><font color="blue">create:</font> handle </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#destruct"><h4><font color="blue">destruct</font> </h4></a><blockquote><font color="green">Write my internal constants to the snarf before I go away.<br></font><br>Overrides: <a href="Heaper.html#destruct">Heaper</a></blockquote><a name="#fetchForward:"><h4><font color="blue">fetchForward:</font> index </h4></a><blockquote><font color="green">If the flock specified by index has been forwarded, return a <a href="FlockLocation.html">FlockLocation</a> with the SnarfID and index of its new location.<br></font></blockquote><a name="#flockOffset:"><h4><font color="blue">flockOffset:</font> index </h4></a><blockquote><font color="green">Return the index of the first byte of the actual data associated with flock number index.  This is like indexOf: except that it leaves room for fencePosts on either side of the flock storage area.<br></font></blockquote><a name="#flocksEnd"><h4><font color="blue">flocksEnd</font> </h4></a><blockquote><font color="green">Return the index of the cell one greater than the size of the entire snarf.  This is just past the end of the storage area for flocks.<br></font></blockquote><a name="#flockSize:"><h4><font color="blue">flockSize:</font> index </h4></a><blockquote><font color="green">Return the number of bytes in the flock at index<br></font></blockquote><a name="#forward:to:with:"><h4><font color="blue">forward:</font> index <font color="blue">to:</font> newSnarfID <font color="blue">with:</font> newIndex </h4></a><blockquote><font color="green">Associate a forwarder with index.  Throw away whatever storage<br>	 was assigned to it and store the forwarder information in the mapCell.<br></font></blockquote><a name="#getOffset:"><h4><font color="blue">getOffset:</font> index </h4></a><blockquote><font color="green">Return the index of the first byte of the actual data associated with<br>	 flock number index.  This area includes space for fencePosts and whatever <br>	 other things we might dream up that go with the flock in its storage area.<br></font></blockquote><a name="#getSize:"><h4><font color="blue">getSize:</font> index </h4></a><blockquote><font color="green">Return the number of bytes in the flock at index.  This includes space allocated internally for fencePosts and the like.<br></font></blockquote><a name="#initializeSnarf"><h4><font color="blue">initializeSnarf</font> </h4></a><blockquote><font color="green">Put in the minimum necessary for a starting snarf.  <br>	 All it needs is the number of objects and the spaceLeft.<br>	 This also writes the information to the real snarf.<br></font></blockquote><a name="#inspect"><h4><font color="blue">inspect</font> </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="Object.html#inspect">Object</a></blockquote><a name="#isForgotten:"><h4><font color="blue">isForgotten:</font> index </h4></a><blockquote><font color="green">The forgotten flag is the flag bit associated with each flock.  It is set when the<br>	flock has been forgotten, which means that there are no more persistent pointers<br>	to the flock.  When a flock is forgotten AND is not in RAM, the <a href="SnarfPacker.html">SnarfPacker</a> is<br>	free to bring the flock back into RAM and destroy it, which deletes it from the snarf.<br>	 <br>	 Return true if the forgotten flag has been set for the flock at index.<br></font></blockquote><a name="#isForwarded:"><h4><font color="blue">isForwarded:</font> index </h4></a><blockquote><font color="green">Return the internal bit that says whether the flock at index is represented by forwarding information or by a flock area<br></font></blockquote><a name="#isOccupied:"><h4><font color="blue">isOccupied:</font> index </h4></a><blockquote><font color="green">Return true if there's a flock or forwarder at index.<br></font></blockquote><a name="#isWritable"><h4><font color="blue">isWritable</font> </h4></a><blockquote><font color="green">Return true if I represent a writable snarf. <br></font></blockquote><a name="#makeWritable"><h4><font color="blue">makeWritable</font> </h4></a><blockquote><font color="green">Make the handle for the receiver writable.<br></font></blockquote><a name="#mapCellOffset:"><h4><font color="blue">mapCellOffset:</font> index </h4></a><blockquote><font color="green">Return the offset into the snarf for the mapCell that has the data for the flock at index.<br></font></blockquote><a name="#mapCount"><h4><font color="blue">mapCount</font> </h4></a><blockquote><font color="green">Return the number of slots allocated in the map table.<br></font></blockquote><a name="#mapEnd"><h4><font color="blue">mapEnd</font> </h4></a><blockquote><font color="green">Return the index of the cell just after the end of the map.  This is based on the number of entries in the map.<br></font></blockquote><a name="#mendFences:"><h4><font color="blue">mendFences:</font> index </h4></a><blockquote><font color="green">Couldn't resist the name.  <a href="Set.html">Set</a> up the fences for the flock at index.  See checkFence:<br></font></blockquote><a name="#nearestFlock"><h4><font color="blue">nearestFlock</font> </h4></a><blockquote><font color="green">Return the location of the nearest flock. Everything between the <br>	end of the map and the nearest flock is free space. We normally <br>	allocate everything from the back of the snarf forward. When we <br>	run out of enough contiguous space, we simply compact.<br>	<br>	We keep a cache of the current nearest flock.  The cache maintins the invariant that it<br>	 *must* point to an offset less than or equal to the nearestFlock.  Thus it can be too close <br>	 to the mapTable, in which case we will recompute it from scratch.<br></font></blockquote><a name="#readStream:"><h4><font color="blue">readStream:</font> index </h4></a><blockquote><font color="green">Return a stream on the area of the snarf allocated to mapIndex.  <br>	 This stream must be used immediately, then thrown away.<br></font></blockquote><a name="#recomputeNearest"><h4><font color="blue">recomputeNearest</font> </h4></a><blockquote><font color="green">Recalculate the nearest flock by looking at the start of every flock and taking the min.<br></font></blockquote><a name="#rewrite"><h4><font color="blue">rewrite</font> </h4></a><blockquote><font color="green">Write out to the snarf any values held in instance variables (space <br>	remaining, number of entries, etc.).<br></font></blockquote><a name="#snarfID"><h4><font color="blue">snarfID</font> </h4></a><blockquote><font color="green">Return the snarfID of the snarf this handle holds.<br></font></blockquote><a name="#snarfMapCount"><h4><font color="blue">snarfMapCount</font> </h4></a><blockquote><font color="green">Actually get from the snarf the number of map slots currently allocated, <br>	including ones that are free for reuse. This is stored as the first thing in the <br>	snarf.<br></font></blockquote><a name="#snarfSpaceLeft"><h4><font color="blue">snarfSpaceLeft</font> </h4></a><blockquote><font color="green">Actually get from the snarf the amount of unallocated space remaining.<br></font></blockquote><a name="#spaceLeft"><h4><font color="blue">spaceLeft</font> </h4></a><blockquote><font color="green">Return the amount space left in the snarf.<br></font></blockquote><a name="#wipeFlock:"><h4><font color="blue">wipeFlock:</font> index </h4></a><blockquote><font color="green">Deallocate all space for the flock at index.  The slot for index remains however, and can be reused for another flock.<br></font></blockquote><a name="#writeStream:"><h4><font color="blue">writeStream:</font> index </h4></a><blockquote><font color="green">Return a stream that can write into the bytes allocated to the flock at index. <br>	 The stream must be used immediately and thrown away.<br></font></blockquote><br><br><a href="index.html">Index</a> - <a href="AllPackages.html">All Packages</a> - <a href="AllCategories.html">All Categories</a> - <a href="AllClasses.html">All Classes</a><br></body>
</html>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5004449-1");
pageTracker._initData();
pageTracker._trackPageview();
</script>
</body>
</html>
