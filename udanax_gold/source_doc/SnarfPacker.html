<html>
<html>
<head>
<title>Class SnarfPacker</title>
</head><body>
<a href="index.html">Index</a> - <a href="AllPackages.html">All Packages</a> - <a href="AllCategories.html">All Categories</a> - <a href="AllClasses.html">All Classes</a><br><h1>Class SnarfPacker</h1>
<font color="green">Should myFlocks contain full flockInfos for forwarded flocks?  Both the flags and the size mean nothing.<br><br>A <a href="SnarfPacker.html">SnarfPacker</a> maintains the relationship between Shepherds and the set of snarfs representing the disk.  A <a href="SnarfPacker.html">SnarfPacker</a> assigns flocks to snarfs based loosely on the flocks's Shepherd's preferences.  When a flock changes, it informs the <a href="SnarfPacker.html">SnarfPacker</a>.  When the <a href="SnarfPacker.html">SnarfPacker</a> decides to write to the disk, it ensures that the changed objects still fit in their snarf (migrating them if necessary), writes them to the snarf, then writes out the snarf.<br><br>mySnarfInfo <br>		- How much space remains in each snarf.<br>mySnarfMap <br>		- Map from snarfIDs to a <a href="SnarfRecord.html">SnarfRecord</a> that handles that snarf.<br>myChangedSnarfs <br>		- The <a href="ID.html">IDs</a> for all snarfs in which an imaged flock has changed.<br>myFlocks <br>		- Indexed by <a href="Abraham.html">Abraham</a> hash, contains all <a href="FlockInfo.html">FlockInfos</a> that refer to flocks in memory.<br>		  Multiple infos may refer to the same flock if it is referenced through forwarding.<br>		  The only info considered to have the correct state wrt its flocks suitability for<br>		  purging is the info pointed to by its <a href="Abraham.html">Abraham</a>.<br>myInsideCommit <br>		- <a href="True.html">True</a> while writing new and changed flocks to disk to prevent purging,<br>		  and during purgeClean to prevent recursive call through <a href="Purgeror.html">Purgeror</a> recycling.<br></font></p>Package: <a href="Package_Udanax-Gold.html">Udanax-Gold</a><br>All Superclasses: <a href="Object.html">Object</a> <a href="Heaper.html">Heaper</a> <a href="DiskManager.html">DiskManager</a> <br>Protocols: <a href="Protocol_Object.html">Object</a><br>Categories: <a href="Category_Xanadu-Snarf.html">Xanadu-Snarf</a><br><hr><h2>Class Methods</h3><a name="#bombResetCommit:"><h4><font color="blue">bombResetCommit:</font> CHARGE </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#initializeUrdiOnDisk:"><h4><font color="blue">initializeUrdiOnDisk:</font> fname </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#linkTimeNonInherited"><h4><font color="blue">linkTimeNonInherited</font> </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="DiskManager.html#linkTimeNonInherited">DiskManager class</a></blockquote><a name="#make:"><h4><font color="blue">make:</font> fname </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="DiskManager.html#make:">DiskManager class</a></blockquote><hr><h2>Instance Methods</h3><a name="#addInfo:with:"><h4><font color="blue">addInfo:</font> info <font color="blue">with:</font> shep </h4></a><blockquote><font color="green">Add another flockInfo object to myFlocks with info about another location for shep.<br></font></blockquote><a name="#assignSnarf:"><h4><font color="blue">assignSnarf:</font> shep </h4></a><blockquote><font color="green">Find a snarf in which to fit shep.  Then assign it to<br>	 that location, and mark that snarf as changed.<br></font></blockquote><a name="#beginConsistent:"><h4><font color="blue">beginConsistent:</font> dirtyFlocks </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="DiskManager.html#beginConsistent:">DiskManager</a></blockquote><a name="#checkInfos"><h4><font color="blue">checkInfos</font> </h4></a><blockquote><font color="green">Perform the sanity check of the moment.  Beware the compile cost of changing this comment.<br></font></blockquote><a name="#commitState:"><h4><font color="blue">commitState:</font> flag </h4></a><blockquote><font color="green">Used by ResetCommit bomb<br></font></blockquote><a name="#commitView"><h4><font color="blue">commitView</font> </h4></a><blockquote><font color="green">Commit by destroying the current view and creating a new one.<br></font></blockquote><a name="#computeSize:"><h4><font color="blue">computeSize:</font> flock </h4></a><blockquote><font color="green">Send the snarf over a transmitter into a stream that just counts the bytes put <br>	into it.<br></font></blockquote><a name="#consistent:with:"><h4><font color="blue">consistent:</font> dirty <font color="blue">with:</font> aBlock </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="DiskManager.html#consistent:with:">DiskManager</a></blockquote><a name="#consistentCount"><h4><font color="blue">consistentCount</font> </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#create:"><h4><font color="blue">create:</font> urdi </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#currentView"><h4><font color="blue">currentView</font> </h4></a><blockquote><font color="green">Return the current urdiView.<br></font></blockquote><a name="#destroyAbandoned"><h4><font color="blue">destroyAbandoned</font> </h4></a><blockquote><font color="green">Destroy all forgotten flocks that are no longer in memory.<br></font></blockquote><a name="#destroyFlock:"><h4><font color="blue">destroyFlock:</font> info </h4></a><blockquote><font color="green">Queue destroy of the given flock.  The destroy will happen later.<br></font><br>Overrides: <a href="DiskManager.html#destroyFlock:">DiskManager</a></blockquote><a name="#destruct"><h4><font color="blue">destruct</font> </h4></a><blockquote><font color="green">Destroy all objects imaged from this snarf.<br></font><br>Overrides: <a href="DiskManager.html#destruct">DiskManager</a></blockquote><a name="#diskUpdate:"><h4><font color="blue">diskUpdate:</font> info </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="DiskManager.html#diskUpdate:">DiskManager</a></blockquote><a name="#dismantleFlock:"><h4><font color="blue">dismantleFlock:</font> info </h4></a><blockquote><font color="green">Turn the flock designated by info into a <a href="Pumpkin.html">Pumpkin</a>.  It should have completed all dismantle actions.<br></font><br>Overrides: <a href="DiskManager.html#dismantleFlock:">DiskManager</a></blockquote><a name="#dropFlock:"><h4><font color="blue">dropFlock:</font> token </h4></a><blockquote><font color="green">The flock is being removed from memory.  For now, this is an error<br>	 if the flock has been updated.  If the flock has been forgotten, <br>	 then it will be dismantled when next it comes in from disk.<br>	 Because of forwarding, there may be many <a href="FlockInfo.html">FlockInfos</a> refering<br>	 to the flock if it is not new.<br></font><br>Overrides: <a href="DiskManager.html#dropFlock:">DiskManager</a></blockquote><a name="#endConsistent:"><h4><font color="blue">endConsistent:</font> dirty </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="DiskManager.html#endConsistent:">DiskManager</a></blockquote><a name="#fetchCanonical:with:with:"><h4><font color="blue">fetchCanonical:</font> hash <font color="blue">with:</font> snarfID <font color="blue">with:</font> index </h4></a><blockquote><font color="green">If something is already imaged at that location, then return it. If there is already<br>	 an existing stub with the same hash at a different location, follow them till we <br>	 know that they are actually different objects.<br></font><br>Overrides: <a href="DiskManager.html#fetchCanonical:with:with:">DiskManager</a></blockquote><a name="#fetchInMemory:with:"><h4><font color="blue">fetchInMemory:</font> snarfID <font color="blue">with:</font> index </h4></a><blockquote><font color="green">Return true if the object is on disk but not in memory.<br></font></blockquote><a name="#flushFlocks"><h4><font color="blue">flushFlocks</font> </h4></a><blockquote><font color="green">Actually write all the changed and newly assigned flocks to the disk.<br></font></blockquote><a name="#forgetFlock:"><h4><font color="blue">forgetFlock:</font> info </h4></a><blockquote><font color="green">Remember that there are no more persistent pointers to the shepherd<br>	 represented by info.  If it gets manually deleted, dismantle it immediately.  <br>	 If it gets garbage collected, remember to dismantle it when it comes back <br>	 in from the disk.<br></font><br>Overrides: <a href="DiskManager.html#forgetFlock:">DiskManager</a></blockquote><a name="#forgottenFlocks:"><h4><font color="blue">forgottenFlocks:</font> snarfID </h4></a><blockquote><font color="green">Return the set of indices to flocks in snarf snarfID that are forgotten.<br></font></blockquote><a name="#forwardFlock:"><h4><font color="blue">forwardFlock:</font> shep </h4></a><blockquote><font color="green">Shep has grown too large for its current place.  Treat it as just a new flock and give it another place.<br></font></blockquote><a name="#getFlock:with:"><h4><font color="blue">getFlock:</font> snarfID <font color="blue">with:</font> index </h4></a><blockquote><font color="green">Return a flock at a particular location.  This needs to register<br>	 the flock if it doesn't exist already.<br></font></blockquote><a name="#getInitialFlock"><h4><font color="blue">getInitialFlock</font> </h4></a><blockquote><font color="green">Return the starting object for the entire backend.  This will be the 0th<br>	 flock in the first snarf following the snarfInfo tables.<br></font><br>Overrides: <a href="DiskManager.html#getInitialFlock">DiskManager</a></blockquote><a name="#getReadHandler:"><h4><font color="blue">getReadHandler:</font> snarfID </h4></a><blockquote><font color="green">Get the read handler on the snarf.<br></font></blockquote><a name="#getSnarfRecord:"><h4><font color="blue">getSnarfRecord:</font> snarfID </h4></a><blockquote><font color="green">Return the snarfRecord for snarfID.  The <a href="SnarfRecord.html">SnarfRecord</a> must exist if there are<br>	 changed flocks imaged out of that snarf, but might not otherwise.  Create it if necessary.<br></font></blockquote><a name="#insideCommit"><h4><font color="blue">insideCommit</font> </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="DiskManager.html#insideCommit">DiskManager</a></blockquote><a name="#isFake"><h4><font color="blue">isFake</font> </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="DiskManager.html#isFake">DiskManager</a></blockquote><a name="#makePersistent"><h4><font color="blue">makePersistent</font> </h4></a><blockquote><font color="green">The virtual image in memory is now in a consistent state. Write the image of <br>	all changed or new Shepherds out to the disk in a single atomic action.  The <br>	atomicity only happens on top of a real <a href="Urdi.html">Urdi</a>, however.<br></font></blockquote><a name="#makeRcvr:"><h4><font color="blue">makeRcvr:</font> readStream </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#makeReal:"><h4><font color="blue">makeReal:</font> info </h4></a><blockquote><font color="green">Retrieve from the disk the flock at index within the specified snarf.  Since<br>	 stubs are canonical, and this only gets called by stubs, the existing stub will <br>	 *become* the shepherd for the flock.<br></font><br>Overrides: <a href="DiskManager.html#makeReal:">DiskManager</a></blockquote><a name="#makeXmtr:"><h4><font color="blue">makeXmtr:</font> writeStream </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#nextHashForEqual"><h4><font color="blue">nextHashForEqual</font> </h4></a><blockquote><font color="green">Shepherds use a sequence number for their hash.  Return the next one<br>	and increment.  This should actually spread the hashes.<br></font><br>Overrides: <a href="DiskManager.html#nextHashForEqual">DiskManager</a></blockquote><a name="#purge"><h4><font color="blue">purge</font> </h4></a><blockquote><font color="green">Flush everything out to disk and remove all purgeable imaged<br>	 objects from memory.<br></font><br>Overrides: <a href="DiskManager.html#purge">DiskManager</a></blockquote><a name="#purgeClean"><h4><font color="blue">purgeClean</font> </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#purgeClean:"><h4><font color="blue">purgeClean:</font> noneLocked </h4></a><blockquote><font color="green">purge all shepherds that are currently clean, not locked, not dirty,<br>	 and purgeable.  Purging just turns them into stubs, freeing all their <br>	 flocks.  Garbage collection can clean up the flocks and any stubs no <br>	 longer pointed to by something in memory.  Because infos for new <br>	 flocks don't appear in myFlocks, this will not throw out any newFlocks <br>	 (which will be marked dirty anyway).  For each <a href="FlockInfo.html">FlockInfo</a>, we check<br>	 that its flock refers to that exact instance to get correct information<br>	 about its dirty state.<br></font><br>Overrides: <a href="DiskManager.html#purgeClean:">DiskManager</a></blockquote><a name="#recordUpdate:"><h4><font color="blue">recordUpdate:</font> info </h4></a><blockquote><font color="green">The flock represented by info has changed.  Record it in the<br>	 bookkeeping data-structures.  This must be called by all things <br>	 that affect whether the flock gets rewritten to disk.<br></font></blockquote><a name="#refitFlocks"><h4><font color="blue">refitFlocks</font> </h4></a><blockquote><font color="green">Make sure all flocks that have changed still fit in their snarfs. <br>	 Add any that don't to myNewFlocks and return the table <br>	 from their current locations to the newShepherds.<br></font></blockquote><a name="#registerStub:with:with:"><h4><font color="blue">registerStub:</font> shep <font color="blue">with:</font> snarfID <font color="blue">with:</font> index </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="DiskManager.html#registerStub:with:with:">DiskManager</a></blockquote><a name="#releaseReadHandler:"><h4><font color="blue">releaseReadHandler:</font> handler </h4></a><blockquote><font color="green">Release the supplied snarfHandler and destroy it.<br></font></blockquote><a name="#rememberFlock:"><h4><font color="blue">rememberFlock:</font> info </h4></a><blockquote><font color="green">There are now persistent pointers to the shepherd help by info.<br></font><br>Overrides: <a href="DiskManager.html#rememberFlock:">DiskManager</a></blockquote><a name="#resolveLocation:"><h4><font color="blue">resolveLocation:</font> info </h4></a><blockquote><font color="green">Make sure that the shepherd or stub at that location actually points<br>	 at the real location for a shepherd.  This will resolve forwarding pointers, <br>	 but not instantiate any flocks.<br></font></blockquote><a name="#setHashCounter:"><h4><font color="blue">setHashCounter:</font> aCounter </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="DiskManager.html#setHashCounter:">DiskManager</a></blockquote><a name="#storeAlmostNewShepherd:"><h4><font color="blue">storeAlmostNewShepherd:</font> shep </h4></a><blockquote><font color="green">Do nothing<br></font><br>Overrides: <a href="DiskManager.html#storeAlmostNewShepherd:">DiskManager</a></blockquote><a name="#storeInitialFlock:with:with:"><h4><font color="blue">storeInitialFlock:</font> turtle <font color="blue">with:</font> protocol <font color="blue">with:</font> cookbook </h4></a><blockquote><font color="green">A turtle just got created!  Write out a pseudo-forwarder that has all the protocol information encoded in the snarfID and index.<br></font><br>Overrides: <a href="DiskManager.html#storeInitialFlock:with:with:">DiskManager</a></blockquote><a name="#storeNewFlock:"><h4><font color="blue">storeNewFlock:</font> shep </h4></a><blockquote><font color="green">Shep just got created! On some later commit, assign it to a snarf <br>	and write it to the disk.<br></font><br>Overrides: <a href="DiskManager.html#storeNewFlock:">DiskManager</a></blockquote><a name="#testNewFlocks"><h4><font color="blue">testNewFlocks</font> </h4></a><blockquote><font color="green"><br></font></blockquote><br><br><a href="index.html">Index</a> - <a href="AllPackages.html">All Packages</a> - <a href="AllCategories.html">All Categories</a> - <a href="AllClasses.html">All Classes</a><br></body>
</html>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5004449-1");
pageTracker._initData();
pageTracker._trackPageview();
</script>
</body>
</html>
