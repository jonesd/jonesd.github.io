<html>
<html>
<head>
<title>Class DiskManager</title>
</head><body>
<a href="index.html">Index</a> - <a href="AllPackages.html">All Packages</a> - <a href="AllCategories.html">All Categories</a> - <a href="AllClasses.html">All Classes</a><br><h1>Class DiskManager</h1>
<font color="green">This is the public interface for managing objects that should go to disk.<br>This is also the anchor for the so-called Backend emulsion, but I'll call it<br>the <a href="DiskManager.html">DiskManager</a> emulsion for simplicity.<br></font></p>Package: <a href="Package_Udanax-Gold.html">Udanax-Gold</a><br>All Superclasses: <a href="Object.html">Object</a> <a href="Heaper.html">Heaper</a> <br>Immediate Subclasses: <a href="CBlockTrackingPacker.html">CBlockTrackingPacker</a> <a href="FakePacker.html">FakePacker</a> <a href="SnarfPacker.html">SnarfPacker</a> <a href="TestPacker.html">TestPacker</a> <br>Protocols: <a href="Protocol_Object.html">Object</a><br>Categories: <a href="Category_Xanadu-Snarf.html">Xanadu-Snarf</a><br><hr><h2>Class Methods</h3><a name="#bombConsistentBlock:"><h4><font color="blue">bombConsistentBlock:</font> CHARGE </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#cleanupGarbage"><h4><font color="blue">cleanupGarbage</font> </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#consistent:"><h4><font color="blue">consistent:</font> aBlock </h4></a><blockquote><font color="green">Execute the block inside a pseudo-transaction.<br></font></blockquote><a name="#consistent:with:"><h4><font color="blue">consistent:</font> dirty <font color="blue">with:</font> aBlock </h4></a><blockquote><font color="green">Execute the block inside a pseudo-transaction.<br></font></blockquote><a name="#consistent:with:with:"><h4><font color="blue">consistent:</font> dirty <font color="blue">with:</font> aBlock <font color="blue">with:</font> context </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#emulsion"><h4><font color="blue">emulsion</font> </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#exitTimeNonInherited"><h4><font color="blue">exitTimeNonInherited</font> </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#initializeDisk:"><h4><font color="blue">initializeDisk:</font> fname </h4></a><blockquote><font color="green">This builds the disk managing structure.<br></font></blockquote><a name="#insistent:"><h4><font color="blue">insistent:</font> aBlock </h4></a><blockquote><font color="green">Execute the block inside a pseudo-transaction.<br></font></blockquote><a name="#insistent:with:"><h4><font color="blue">insistent:</font> dirty <font color="blue">with:</font> aBlock </h4></a><blockquote><font color="green">Execute the block inside a pseudo-transaction.<br></font></blockquote><a name="#insistent:with:with:"><h4><font color="blue">insistent:</font> dirty <font color="blue">with:</font> aBlock <font color="blue">with:</font> context </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#linkTimeNonInherited"><h4><font color="blue">linkTimeNonInherited</font> </h4></a><blockquote><font color="green"><br></font><br>Overridden by: <a href="SnarfPacker.html#linkTimeNonInherited">SnarfPacker class</a> </blockquote><a name="#make:"><h4><font color="blue">make:</font> fname </h4></a><blockquote><font color="green"><br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#make:">CBlockTrackingPacker class</a> <a href="SnarfPacker.html#make:">SnarfPacker class</a> </blockquote><a name="#staticTimeNonInherited"><h4><font color="blue">staticTimeNonInherited</font> </h4></a><blockquote><font color="green"><br></font></blockquote><hr><h2>Instance Methods</h3><a name="#actualHashForEqual"><h4><font color="blue">actualHashForEqual</font> </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#beginConsistent:"><h4><font color="blue">beginConsistent:</font> dirty </h4></a><blockquote><font color="green">This is called before entering consistent block.  'dirty' is the block's declaration of the maximum number of shepherds which it can dirty.  If this is a top level consistent block, the virtual image in memory is now in a consistent state. It may be written to the disk if necessary.  <br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#beginConsistent:">CBlockTrackingPacker</a> <a href="FakePacker.html#beginConsistent:">FakePacker</a> <a href="SnarfPacker.html#beginConsistent:">SnarfPacker</a> <a href="TestPacker.html#beginConsistent:">TestPacker</a> </blockquote><a name="#consistent:"><h4><font color="blue">consistent:</font> aBlock </h4></a><blockquote><font color="green">Execute the block inside a pseudo-transaction.<br></font></blockquote><a name="#consistent:with:"><h4><font color="blue">consistent:</font> dirty <font color="blue">with:</font> aBlock </h4></a><blockquote><font color="green">Execute the block inside a pseudo-transaction.<br></font><br>Overridden by: <a href="SnarfPacker.html#consistent:with:">SnarfPacker</a> </blockquote><a name="#consistentBlockAt:with:"><h4><font color="blue">consistentBlockAt:</font> fileName <font color="blue">with:</font> lineNo </h4></a><blockquote><font color="green">This is called after beginConsistent, but before entering a consistent block, for debugging purposes.  Default is to do nothing<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#consistentBlockAt:with:">CBlockTrackingPacker</a> </blockquote><a name="#create"><h4><font color="blue">create</font> </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="Heaper.html#create">Heaper</a><br>Overridden by: <a href="FakePacker.html#create">FakePacker</a> </blockquote><a name="#destroyFlock:"><h4><font color="blue">destroyFlock:</font> info </h4></a><blockquote><font color="green">Queue destroy of the given flock.  The destroy will probably happen later.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#destroyFlock:">CBlockTrackingPacker</a> <a href="FakePacker.html#destroyFlock:">FakePacker</a> <a href="SnarfPacker.html#destroyFlock:">SnarfPacker</a> <a href="TestPacker.html#destroyFlock:">TestPacker</a> </blockquote><a name="#destruct"><h4><font color="blue">destruct</font> </h4></a><blockquote><font color="green"><br></font><br>Overrides: <a href="Heaper.html#destruct">Heaper</a><br>Overridden by: <a href="CBlockTrackingPacker.html#destruct">CBlockTrackingPacker</a> <a href="SnarfPacker.html#destruct">SnarfPacker</a> </blockquote><a name="#diskUpdate:"><h4><font color="blue">diskUpdate:</font> info </h4></a><blockquote><font color="green">The flock described by info is Dirty! On the next commit, rewrite it to the disk.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#diskUpdate:">CBlockTrackingPacker</a> <a href="FakePacker.html#diskUpdate:">FakePacker</a> <a href="SnarfPacker.html#diskUpdate:">SnarfPacker</a> <a href="TestPacker.html#diskUpdate:">TestPacker</a> </blockquote><a name="#dismantleFlock:"><h4><font color="blue">dismantleFlock:</font> info </h4></a><blockquote><font color="green">The flock designated by info has completed all dismantling actions; throw it off the disk.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#dismantleFlock:">CBlockTrackingPacker</a> <a href="FakePacker.html#dismantleFlock:">FakePacker</a> <a href="SnarfPacker.html#dismantleFlock:">SnarfPacker</a> <a href="TestPacker.html#dismantleFlock:">TestPacker</a> </blockquote><a name="#dropFlock:"><h4><font color="blue">dropFlock:</font> token </h4></a><blockquote><font color="green">The flock identified by token is being removed from memory. For now, this is an <br>	error if the flock has been updated. If the flock has been forgotten, then it will <br>	be dismantled when next it comes in from disk.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#dropFlock:">CBlockTrackingPacker</a> <a href="FakePacker.html#dropFlock:">FakePacker</a> <a href="SnarfPacker.html#dropFlock:">SnarfPacker</a> <a href="TestPacker.html#dropFlock:">TestPacker</a> </blockquote><a name="#endConsistent:"><h4><font color="blue">endConsistent:</font> dirty </h4></a><blockquote><font color="green">This is called after exiting a consistent block.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#endConsistent:">CBlockTrackingPacker</a> <a href="FakePacker.html#endConsistent:">FakePacker</a> <a href="SnarfPacker.html#endConsistent:">SnarfPacker</a> <a href="TestPacker.html#endConsistent:">TestPacker</a> </blockquote><a name="#fetchCanonical:with:with:"><h4><font color="blue">fetchCanonical:</font> hash <font color="blue">with:</font> snarfID <font color="blue">with:</font> index </h4></a><blockquote><font color="green">If something is already imaged at that location, then return it. If there is already<br>	 an existing stub with the same hash at a different location, follow them both till we <br>	 know that they are actually different objects.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#fetchCanonical:with:with:">CBlockTrackingPacker</a> <a href="FakePacker.html#fetchCanonical:with:with:">FakePacker</a> <a href="SnarfPacker.html#fetchCanonical:with:with:">SnarfPacker</a> <a href="TestPacker.html#fetchCanonical:with:with:">TestPacker</a> </blockquote><a name="#flockInfoTable"><h4><font color="blue">flockInfoTable</font> </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#flockInfoTable:"><h4><font color="blue">flockInfoTable:</font> table </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#flockTable"><h4><font color="blue">flockTable</font> </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#flockTable:"><h4><font color="blue">flockTable:</font> table </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#fluidSpace"><h4><font color="blue">fluidSpace</font> </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#fluidSpace:"><h4><font color="blue">fluidSpace:</font> aFluidSpace </h4></a><blockquote><font color="green"><br></font></blockquote><a name="#forgetFlock:"><h4><font color="blue">forgetFlock:</font> info </h4></a><blockquote><font color="green">Remember that there are no more persistent pointers to the shepherd <br>	described by info. If it gets garbage collected, remember to dismantle it <br>	when it comes back in from the disk.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#forgetFlock:">CBlockTrackingPacker</a> <a href="FakePacker.html#forgetFlock:">FakePacker</a> <a href="SnarfPacker.html#forgetFlock:">SnarfPacker</a> <a href="TestPacker.html#forgetFlock:">TestPacker</a> </blockquote><a name="#getInitialFlock"><h4><font color="blue">getInitialFlock</font> </h4></a><blockquote><font color="green">Return the starting object for the entire backend. This will be the 0th <br>	flock in the first snarf following the snarfInfo tables. This will eventually <br>	always be a shepherd that describes the protocol of the rest of the disk.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#getInitialFlock">CBlockTrackingPacker</a> <a href="FakePacker.html#getInitialFlock">FakePacker</a> <a href="SnarfPacker.html#getInitialFlock">SnarfPacker</a> <a href="TestPacker.html#getInitialFlock">TestPacker</a> </blockquote><a name="#insideCommit"><h4><font color="blue">insideCommit</font> </h4></a><blockquote><font color="green"><br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#insideCommit">CBlockTrackingPacker</a> <a href="FakePacker.html#insideCommit">FakePacker</a> <a href="SnarfPacker.html#insideCommit">SnarfPacker</a> <a href="TestPacker.html#insideCommit">TestPacker</a> </blockquote><a name="#isFake"><h4><font color="blue">isFake</font> </h4></a><blockquote><font color="green"><br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#isFake">CBlockTrackingPacker</a> <a href="FakePacker.html#isFake">FakePacker</a> <a href="SnarfPacker.html#isFake">SnarfPacker</a> <a href="TestPacker.html#isFake">TestPacker</a> </blockquote><a name="#makeConsistent"><h4><font color="blue">makeConsistent</font> </h4></a><blockquote><font color="green">The virtual image in memory is now in a consistent state. It may be written to <br>	the disk if necessary.<br></font><br>Overridden by: <a href="TestPacker.html#makeConsistent">TestPacker</a> </blockquote><a name="#makeConsistentBegin:"><h4><font color="blue">makeConsistentBegin:</font> dirty </h4></a><blockquote><font color="green">The virtual image in memory is now in a consistent state. It may be written to the disk if necessary.  This is called before entering a top level consistent block.  'dirty' is the block's declaration of the maximum number of shepherds which it can dirty.<br></font></blockquote><a name="#makeConsistentEnd"><h4><font color="blue">makeConsistentEnd</font> </h4></a><blockquote><font color="green">This is called after exiting a top level consistent block.<br></font></blockquote><a name="#makeReal:"><h4><font color="blue">makeReal:</font> info </h4></a><blockquote><font color="green">Retrieve from the disk the flock at index within the specified snarf.  Since<br>	 stubs are canonical, and this only gets called by stubs, the existing stub will <br>	 *become* the shepherd for the flock.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#makeReal:">CBlockTrackingPacker</a> <a href="FakePacker.html#makeReal:">FakePacker</a> <a href="SnarfPacker.html#makeReal:">SnarfPacker</a> <a href="TestPacker.html#makeReal:">TestPacker</a> </blockquote><a name="#nextHashForEqual"><h4><font color="blue">nextHashForEqual</font> </h4></a><blockquote><font color="green">Shepherds use a sequence number for their hash. The most trivial (reasonable) <br>	implementation just uses a <a href="BatchCounter.html">BatchCounter</a>. This will not be persistent till we get <br>	<a href="Turtle.html">Turtles</a>.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#nextHashForEqual">CBlockTrackingPacker</a> <a href="FakePacker.html#nextHashForEqual">FakePacker</a> <a href="SnarfPacker.html#nextHashForEqual">SnarfPacker</a> <a href="TestPacker.html#nextHashForEqual">TestPacker</a> </blockquote><a name="#purge"><h4><font color="blue">purge</font> </h4></a><blockquote><font color="green">Flush everything out to disk and remove all purgeable imaged objects from memory. <br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#purge">CBlockTrackingPacker</a> <a href="FakePacker.html#purge">FakePacker</a> <a href="SnarfPacker.html#purge">SnarfPacker</a> <a href="TestPacker.html#purge">TestPacker</a> </blockquote><a name="#purgeClean:"><h4><font color="blue">purgeClean:</font> noneLocked </h4></a><blockquote><font color="green">purge all shepherds that are currently clean, not locked, not dirty, and <br>	purgeable. Purging just turns them into stubs, freeing the rest of their flocks. <br>	Garbage collection can clean up the flocks and any stubs no longer pointed to <br>	by something in memory.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#purgeClean:">CBlockTrackingPacker</a> <a href="FakePacker.html#purgeClean:">FakePacker</a> <a href="SnarfPacker.html#purgeClean:">SnarfPacker</a> <a href="TestPacker.html#purgeClean:">TestPacker</a> </blockquote><a name="#registerStub:with:with:"><h4><font color="blue">registerStub:</font> shep <font color="blue">with:</font> snarfID <font color="blue">with:</font> index </h4></a><blockquote><font color="green">Called to register a newly created stub (by the diskSpecialist) in the internal <br>	tables. The diskSpecialist in particular calls this when it couldn't find an <br>	already existing stub (with fetchCacnonical) representing the flock at the <br>	particular location.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#registerStub:with:with:">CBlockTrackingPacker</a> <a href="FakePacker.html#registerStub:with:with:">FakePacker</a> <a href="SnarfPacker.html#registerStub:with:with:">SnarfPacker</a> <a href="TestPacker.html#registerStub:with:with:">TestPacker</a> </blockquote><a name="#rememberFlock:"><h4><font color="blue">rememberFlock:</font> info </h4></a><blockquote><font color="green">There are now persistent pointers to the shepherd described by info.  See forgetFlock.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#rememberFlock:">CBlockTrackingPacker</a> <a href="FakePacker.html#rememberFlock:">FakePacker</a> <a href="SnarfPacker.html#rememberFlock:">SnarfPacker</a> <a href="TestPacker.html#rememberFlock:">TestPacker</a> </blockquote><a name="#setHashCounter:"><h4><font color="blue">setHashCounter:</font> aCounter </h4></a><blockquote><font color="green"><br></font><br>Overridden by: <a href="SnarfPacker.html#setHashCounter:">SnarfPacker</a> </blockquote><a name="#storeAlmostNewShepherd:"><h4><font color="blue">storeAlmostNewShepherd:</font> shep </h4></a><blockquote><font color="green">Shep has been created, but is not consistent yet. storeNewFlock must be called on it before the next makeConsistent.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#storeAlmostNewShepherd:">CBlockTrackingPacker</a> <a href="FakePacker.html#storeAlmostNewShepherd:">FakePacker</a> <a href="SnarfPacker.html#storeAlmostNewShepherd:">SnarfPacker</a> <a href="TestPacker.html#storeAlmostNewShepherd:">TestPacker</a> </blockquote><a name="#storeInitialFlock:with:with:"><h4><font color="blue">storeInitialFlock:</font> turtle <font color="blue">with:</font> protocol <font color="blue">with:</font> cookbook </h4></a><blockquote><font color="green">A turtle just got created! Remember it as the initial flock.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#storeInitialFlock:with:with:">CBlockTrackingPacker</a> <a href="FakePacker.html#storeInitialFlock:with:with:">FakePacker</a> <a href="SnarfPacker.html#storeInitialFlock:with:with:">SnarfPacker</a> <a href="TestPacker.html#storeInitialFlock:with:with:">TestPacker</a> </blockquote><a name="#storeNewFlock:"><h4><font color="blue">storeNewFlock:</font> shep </h4></a><blockquote><font color="green">Shep just got created! On some later commit, assign it to a snarf <br>	and write it to the disk.<br></font><br>Overridden by: <a href="CBlockTrackingPacker.html#storeNewFlock:">CBlockTrackingPacker</a> <a href="FakePacker.html#storeNewFlock:">FakePacker</a> <a href="SnarfPacker.html#storeNewFlock:">SnarfPacker</a> <a href="TestPacker.html#storeNewFlock:">TestPacker</a> </blockquote><br><br><a href="index.html">Index</a> - <a href="AllPackages.html">All Packages</a> - <a href="AllCategories.html">All Categories</a> - <a href="AllClasses.html">All Classes</a><br></body>
</html>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5004449-1");
pageTracker._initData();
pageTracker._trackPageview();
</script>
</body>
</html>
